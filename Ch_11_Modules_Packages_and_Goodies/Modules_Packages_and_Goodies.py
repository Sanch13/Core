from collections import defaultdict, Counter


"""Обрабатываем отсутствующие ключи с помощью функций setdefault() и defaultdict()"""

""""Вы уже знаете, что попытка получить доступ к словарю с помощью несуществующего ключа
генерирует исключение. Избежать этого помогает функция словаря get() для возврата значения 
по умолчанию. Функция setdefault() похожа функцию get(), но кроме того, она 
присваивает элемент словарю, если заданный ключ отсутствует"""

periodic_table = {'Hydrogen': 1, 'Helium': 2}
periodic_table.setdefault('Carbon', 12)
# periodic_table  #{'Hydrogen': 1, 'Helium': 2, 'Carbon': 12}

"""Функция defaultdict() похожа на предыдущую, но она определяет значение по умолчанию для новых 
ключей заранее, при создании словаря. В этом примере мы передаем функцию int, которая
будет вызываться как int() и возвращать значение 0:"""

periodic_table = defaultdict(int)
periodic_table['Hydrogen'] = 1
periodic_table['Lead']
# periodic_table   #defaultdict(<class 'int'>, {'Hydrogen': 1, 'Lead': 0})
"""Аргументом defaultdict() является функция, возвращающая значение, которое будет присвоено 
отсутствующему ключу. В следующем примере функция no_idea() вызывается всякий раз, когда 
нужно вернуть значение. Вы можете использовать функции int(), list() или dict(), чтобы возвращать
пустые значения по умолчанию: int() возвращает 0, list() возвращает пустой список [], 
dict() возвращает пустой словарь {}. Если вы опустите аргумент, исходное значение нового ключа 
будет равно None.Кстати, вы можете использовать lambda для того, чтобы определить функцию по
умолчанию внутри вызова"""
"""Использовать int — это один из способов создать собственный счетчик"""
food_counter = defaultdict(int)
for food in ['spam', 'spam', 'eggs', 'spam']:
    food_counter[food] += 1

# for food, count in food_counter.items():
    # print(food, count, end=' ')           #spam 3 eggs 1

"""Подсчитываем элементы с помощью функции Counter(). Если говорить о счетчиках, то в 
стандартной библиотеке имеется счетчик"""
breakfast = ['spam', 'spam', 'eggs', 'spam']
breakfast_counter = Counter(breakfast)      # Counter({'spam': 3, 'eggs': 1})

"""Функция most_common() возвращает все элементы в убывающем порядке или только те элементы,
количество которых больше, чем заданный аргумент count:"""
# breakfast_counter.most_common()     # Counter({'spam': 3, 'eggs': 1})

"""Стек + очередь == deque. 
Список-подобная последовательность, оптимизированная для доступа к данным вблизи конечных точек.
deque (произносится как «дэк») — это двусторонняя очередь, которая имеет функции как стека, так 
и очереди. Она полезна, когда нужно добавить или удалить элементы с любого конца 
последовательности. В следующем примере мы будем двигаться с обоих концов слова к его 
середине, чтобы проверить, является ли оно палиндромом. Функция popleft() удаляет крайний 
слева элемент и возвращает его, функция pop() удаляет крайний справа элемент и возвращает его.
Вместе они движутся с концов слова к его середине. Эти действия продолжатся до тех пор, 
пока совпадают крайние символы и пока не будет достигнута середина:"""


def palindrome(word):
    from collections import deque
    dq = deque(word)                    # пермен. dq присв. фун. deque и передаем арг. слово word
    while len(dq) > 1:                  # пока длина последовательности больше 1 выполняем код ниже
        if dq.popleft() != dq.pop():    # возвращ. элем. с лево и право. сравниваем и удаляем их
            return False                # Если элем. не равны возвращаем False
    return True                         # возвращаем True если все элементы равны

palindrome('racecar')                   # True
palindrome('halibut')                   # False


def is_palindrome(word):
    return f'{word.capitalize()} is {"palindrome" if word == word[::-1] else "not palindrome"}'

# print(is_palindrome('racecar')) # Racecar is palindrome
# print(is_palindrome('halibut')) # Halibut is not palindrome

"""Модуль itertools (https://docs.python.org/3/library/itertools.html) содержит особые функции 
итератора. Все они возвращают один элемент при каждом вызове из цикла for… in и запоминают 
свое состояние между вызовами."""
"""Функция chain() проходит по своим аргументам, как если бы они были единым итерабельным объектом
"""
import itertools
# for item in itertools.chain([1, 2], ['a', 'b']):
#     print(item, end=' ')                          # 1 2 a b
"""Функция cycle() является бесконечным итератором, проходящим в цикле по своим аргументам"""
"""Функция accumulate() подсчитывает накопленные значения. По умолчанию она высчитывает сумму"""
"""Красиво выводим данные на экран с помощью функции pprint()"""
""" В таком случае стоит вспомнить о том, что существует целый мир стороннего программного 
обеспечения Python с открытым исходным кодом. Отлично зарекомендовали себя следующие ресурсы:
- PyPi (известный также как Cheese Shop («Магазин сыра») после старой пародии Monty Python)
(http://pypi.python.org/);
- github (https://github.com/Python);
- readthedocs (https://readthedocs.org/)."""



