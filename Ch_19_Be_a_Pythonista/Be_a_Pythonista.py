import string

"""Когда вам нужно написать некий код, самым быстрым решением является кража…из тех источников, 
которые позволяют это делать. Стандартная библиотека Python (http://docs.python.org/3/library) 
широка, глубока и довольно понятна."""
"""Первое место, на которое вы должны обратить внимание, — это каталог пакетов Python 
(Python Package Index, PyPI) (https://pypi.org/)."""
"""Еще один популярный репозиторий — GitHub. Взгляните, какие пакеты Python популярны в данный 
момент (https://github.com/trending?l=python)."""
"""Сайт Popular Python recipes (http://bit.ly/popular-recipes) содержит более 4000 коротких 
программ Python на любую тему"""

"""virtualenv
Стандартный способ установки сторонних пакетов — это использование pip и virtualenv. 
Виртуальное окружение — это обычный каталог, содержащий интерпретатор Python, несколько других 
программ наподобие pip, а также некие пакеты. Вы можете активизировать его, запустив сценарий 
оболочки, который лежит в каталоге bin этого виртуального окружения. Это изменит значение 
переменной окружения $PATH, и теперь ваша оболочка будет знать, где искать программы. Активизируя
виртуальное окружение, вы помещаете его каталог bin перед остальными каталогами в переменной 
$PATH. В результате, когда вы введете такие команды, как pip или python, ваша оболочка сначала 
найдет те программы, которые располагаются в вашем виртуальном окружении, а не те, что находятся 
в системных каталогах"""

"""Добавление подсказок типов
Статические языки требуют от вас определять типы переменных, они могут отлавливать ошибки на 
этапе компиляции. Python так не делает, вы можете столкнуться с багом только при запуске кода. 
Переменные в Python — это имена, они лишь ссылаются на реальные объекты. Объекты имеют строго 
определенный тип, но имя может указывать на разные объекты в различные моменты времени.
В реальном коде (на Python и других языках) имя, как правило, ссылается на конкретный объект. 
Было бы полезно, по крайней мере в документации, если бы мы могли оставлять аннотации (к 
объектам, возвращаемым значениям функций и т. д.), указывавшие бы на ожидаемый тип объекта, 
на который они ссылаются. В таком случае разработчикам не пришлось бы просматривать большое 
количество кода, чтобы увидеть, как переменная должна вести себя. В Python версий 3.х для решения 
этой проблемы были добавлены подсказки типов (или аннотации типов). Ими пользоваться не 
обязательно, они не задают жесткий тип переменной. Подсказки типов предназначены для того, 
чтобы помочь разработчикам, привыкшим к статическим языкам, понять, где должны быть объявлены 
типы переменных. Подсказка для функции, которая преобразует строку в число, может выглядеть так:"""


def num_to_str(num: int) -> str:
    return str(num)


"""Это лишь подсказки, они не меняют способ работы Python. Они нужны для документирования, 
однако люди придумывают и другое применение. Например, веб-фреймворк FastAPI 
(https://fastapi.tiangolo.com/) использует подсказки для того, чтобы сгенерировать 
веб-документацию, а также лайв-формы для тестирования."""

"""Программы pylint, pyflakes, flake8 или PEP-8
Следующий шаг перед созданием настоящих программ для тестирования — использование контролера
кода Python. Самыми популярными являются pylint (http://www.pylint.org/) и 
pyflakes (http://bit.ly/pyflakes).Они проверяют на наличие реальных ошибок в коде 
(например, обращения к переменной до присвоения ей значения) и несоответствие стилю (как если бы
код носил одновременно одежду в полоску и клетку)."""
import pylint

# a = 1
# b = 2
# print(a)
# print(b)
# print(c)
"""Так выглядит выходная информация от pylint:"""
# Be_a_Pythonista.py:52:0: C0103: Constant name "a" doesn't conform to UPPER_CASE naming style (invalid-name)
# Be_a_Pythonista.py:53:0: C0103: Constant name "b" doesn't conform to UPPER_CASE naming style (invalid-name)
# Be_a_Pythonista.py:56:6: E0602: Undefined variable 'c' (undefined-variable)
"""Если пролистать дальше, к разделу Global evaluation, то можно увидеть наш счет
(10.0 — это высший балл):"""
# Your code has been rated at 0.00/10
"""исправим ошибку"""
a = 1
b = 2
c = 3
print(a)
print(b)
print(c)

"""Тестирование кода
Возможно, вы уже знаете, однако на всякий случай напомню: даже тривиальные изменения в коде могут 
сломать вашу программу. В Python недостает проверки типов, присущей статическим языкам, 
что упрощает некоторые аспекты программирования, но повышает вероятность получить нежелательные 
результаты. Тестирование — это важно. Самый простой способ протестировать программы, написанные 
на Python, — добавить операторы print(). Read-Evaluate-Print Loop (REPL) интерактивного 
интерпретатора позволяет быстро изменять код и тестировать изменения. Однако в производственном 
коде операторы print() использовать не стоит, поэтому вам нужно помнить о том, что их все 
следует удалять.
"""

"""Пакет unittest
Хорошим тоном являются написание и запуск тестовых программ до отправки кода в систему контроля
исходного кода. Написание тестов поначалу может быть утомительным, но они действительно помогают 
находить проблемы быстрее, особенно регрессионные тесты (суть которых заключается в том, чтобы 
сломать то, что раньше работало). Болезненный опыт учит всех разработчиков: даже самое маленькое 
изменение, которое, по их заверениям, не затрагивает другие области приложения, на самом деле
влияет на них. Если вы взглянете на качественные пакеты Python, то заметите, что они поставляются
с набором тестов.Стандартная библиотека содержит не один, а целых два пакета для 
тестирования приложений. Начнем с unittest (https://oreil.ly/ImFmE). Модуль cap.by записывает 
слова с прописной буквы. Наша первая версия будет использовать стандартную строковую 
функцию capitalize().
Основная идея тестирования заключается в том, чтобы понять, какой результат вы хотите получить 
при определенных входных данных (в нашем примере вы хотите получить введенный текст записанным с 
прописной буквы), отправить результат функции тестирования, а затем проверить, получен ли 
ожидаемый результат. Ожидаемый результат называется утверждением (assertion), поэтому в рамках 
пакета unittest вы проверяете результат с помощью методов, чьи имена начинаются со слова assert, 
скажем метода assertEqual.
Перед каждым методом тестирования вызывается метод setUp(), а после каждого из методов 
тестирования — метод tearDown(). Их задача — выделение и освобождение внешних ресурсов, 
необходимых для тестов, таких как соединение с базой данных или создание неких тестовых данных. 
В нашем случае тесты автономны, и нам даже не нужно определять методы setUp() и tearDown(), 
однако создать их пустые версии не повредит. Сердце наших тестов — две функции с именами test_
one_word() и test_multiple_words(). Каждая из них запускает определенную нами функцию just_do_it(
) с разными входными параметрами и проверяет, получен ли ожидаемый результат. 
Эта команда вызовет два наших методатестирования:
    # AssertionError: 'A veritable flock of ducks' != 'A Veritable Flock Of Ducks'
    # - A veritable flock of ducks
    # ?   ^         ^     ^  ^
    # + A Veritable Flock Of Ducks
    # ?   ^         ^     ^  ^
Пакет устроил результат первой проверки (test_one_word), но не результат второй (
test_multiple_words). Стрелки вверх (^) показывают, какие строки отличаются.
Функции capitalize увеличивает только первую букву первого слова. Нам нужна другая функция. 
Используем функцию title(). Результат:
    # Ran 2 tests in 0.002s
    # OK
Все прошло отлично. Хотя на самом деле нет.  Наша функция увеличила букву m в конструкции 
I'm. В документации к функции title() мы обнаружили, что она плохо работает с апострофами. 
"""




