import string

"""Хранилища данных NoSQL
Реляционные таблицы имеют форму прямоугольника, но поступающие данные могут иметь разную форму
и их размещение требует больших усилий. Это похоже на проблему квадратного колышка и круглой дырки.
Отдельные нереляционные базы данных позволяют более гибко определять данные, работают с очень
крупными наборами и поддерживают пользовательские операции с данными. Такие базы данных
называют NoSQL (раньше это означало «не SQL», теперь же расшифровка звучит как «не только SQL»).
Простейшей вариацией баз данных NoSQL являются хранилища ключей-значений."""

"""Семейство dbm
Форматы dbm существовали задолго до того, как появился NoSQL. Они представляют собой простые
хранилища, работающие по принципу «ключ — значение». Их часто встраивают в приложения вроде
браузеров, чтобы поддерживать различные настройки. База данных dbm похожа на обычный словарь в
следующих отношениях:
- вы присваиваете значение ключу, и оно автоматически сохраняется в базе данных на диске;
- вы можете получить ключ по его значению.
"""
"""Рассмотрим простой пример. Второй аргумент следующего метода open() может принимать значения
'r' для чтения, 'w' для записи и 'c' для того и другого, создавая файл, если его не существует"""
import dbm
db = dbm.open('definitions', 'c')
"""Для того чтобы создать пары «ключ — значение», просто присвойте значение ключу, как если бы
вы работали со словарем:"""
db['_mustard'] = '_yellow'
db['_ketchup'] = '_red'
db['_pesto'] = '_green'
# print(len(db))        # 3
# print(db['_pesto'])   # b'_green'
"""Теперь закроем файл и откроем его снова, чтобы убедиться, действительно ли
наши данные были сохранены"""
db.close()
db = dbm.open('definitions', 'r')
# print(db['_mustard'])   # b'_yellow'
db.close()
"""Ключи и значения сохраняются как байты. Вы не можете итерировать по объектам базы данных db,
но можете получить количество ключей с помощью функции len(). Обратите внимание на то, что
функции get() и setdefault() работают точно так же, как и для словарей"""

"""Memcached
memcached (http://memcached.org/) — это быстрый сервер кэширования, располагающийся в памяти
и работающий по принципу «ключ — значение». Часто его размещают перед базой данных или используют
для хранения данных сессии веб-сервера.
Вы можете загрузить версии для Linux, macOS (http://bit.ly/install-osx)
Windows (http://bit.ly/memcache-win).
Существует множество драйверов Python. Тот, что работает с Python 3, называется
python3-memcached (https://github.com/eguven/python3-memcached).
Ключи и значения, хранимые в базе, неустойчивы и могут исчезать. Это происходит из-за того,
что memcached является сервером кэша, а не базой данных. Он избегает ситуаций, когда у него
заканчивается память, стирая старые данные."""

"""Redis
Redis — это сервер структур данных. Он работает с ключами и их значениями, но значения имеют
гораздо больше возможностей, чем в других хранилищах. Как и в случае с memcached, все данные
сервера Redis должны поместиться в память (хотя у нас имеется возможность сохранить все данные
на диск). В отличие от memcached Redis может делать следующее:
- сохранять данные на диск для надежности в случае перезагрузки;
- хранить старые данные;
- предоставлять более сложные, по сравнению со строками, структуры данных.
Типы данных Redis близки к типам данных Python, и сервер Redis может быть полезным посредником
для обмена данными между приложениями.
Исходный код драйвера Python redis-py и тесты находятся на 
GitHub (https://github.com/andymccurdy/redis-py),
документация по нему находится по адресу http://bit.ly/redis-py-docs.
Сам по себе сервер Redis (http://redis.io/) хорошо задокументирован. Если вы установите и
запустите его на своем локальном компьютере, который имеет сетевое имя localhost, вы сможете
запустить программы, описанные в следующих подразделах.

Строки.
Ключ, имеющий одно значение, является строкой Redis. Простые типы данных Python автоматически
преобразуются. Подключимся к серверу Redis, расположенному на определенных хосте
(по умолчанию localhost) и порте (по умолчанию 6379):
"""

import redis
conn = redis.Redis()
"""Строки redis.Redis('localhost') или redis.Redis('localhost', 6379) дадут тот же результат."""
# conn.set('secret', 'ni!')
# conn.get('secret')    # b'ni!'
"""Метод setnx() устанавливает значение, но только если ключа не существует:"""
"""Метод getset() возвращает старое значение и одновременно устанавливает новое"""
# conn.getset('secret', 'icky-icky-icky-ptang-zoop-boing!')
# b'ni!'
# conn.get('secret')  # b'icky-icky-icky-ptang-zoop-boing!'
"""получим подстроку с помощью метода getrange() (как и в Python, 
смещение 0 означает начало списка, −1 — конец)"""
# conn.getrange('secret', -6, -1) # b'boing!'
"""Заменим подстроку с помощью метода setrange() (используя смещение, которое начинается с нуля)"""
# conn.setrange('secret', 0, 'ICKY')
# conn.get('secret')  # b'ICKY-icky-icky-ptang-zoop-boing!'
"""Далее установим значения сразу нескольких ключей с помощью метода mset():"""
# conn.mset({'pie': 'cherry', 'cordial': 'sherry'})
"""Получим более одного значения с помощью метода mget():"""
# conn.mget(['pie', 'cordial'])   # [b'cherry', b'sherry']
"""Удалим ключ с помощью метода delete():"""
# conn.delete('pie')
"""инкремент с помощью команд incr() и incrbyfloat() и декремент с помощью команды decr()"""
"""Команды decrbyfloat() не существует. Используйте отрицательный инкремент, 
чтобы уменьшить значение ключа"""

"""Списки. 
Списки Redis могут содержать только строки. Список создается, когда вы добавляете первые данные.
Добавим данные в начало списка с помощью метода lpush():"""
# conn.lpush('zoo', 'bear')   # 1 arg - название списка (явл. ключем), 2 - *arg - values
"""Добавим в начало списка более одного элемента:"""
# conn.lpush('zoo', 'alligator', 'duck')
"""Добавим один элемент до или после другого с помощью метода linsert()"""
# conn.linsert('zoo', 'before', 'bear', 'beaver')
"""Добавим элемент, указав смещение для него, с помощью метода lset() (список уже должен
 существовать):"""
# conn.lset('zoo', 2, 'marmoset')
"""Добавим элемент в конец с помощью метода rpush():"""
# conn.rpush('zoo', 'yak')
"""Получим элемент по заданному смещению с помощью метода lindex():"""
# conn.lindex('zoo', 3)   # b'bear'

"""Хеши.
Хеши Redis похожи на словари в Python, но содержат только строки, поэтому мы можем создать
только одномерный словарь. Рассмотрим примеры, в которых создается и изменяется хеш
с именем song."""
"""Установим в хеше song значения полей do и re одновременно с помощью метода hmset()"""
# conn.hmset('song', {'do': 'a deer', 're': 'about a deer'})
"""Установим значение одного поля хеша с помощью метода hset():"""
# conn.hset('song', 'mi', 'a note to follow re')
"""Получим значение одного поля с помощью метода hget()"""
# conn.hget('song', 'mi')     # b'a note to follow re'
"""Получим значение нескольких полей с помощью метода hmget():"""
# conn.hmget('song', 're', 'do')  # [b'about a deer', b'a deer']
"""Получим ключи всех полей хеша с помощью метода hkeys()"""
# conn.hkeys('song')     # [b'do', b're', b'mi']
"""Получим значения всех полей хеша с помощью метода hvals():"""
# conn.hvals('song')  # [b'a deer', b'about a deer', b'a note to follow re']
"""Получим количество полей хеша с помощью функции hlen()"""
# conn.hlen('song')   # 3
"""Получим ключи и значения всех полей хеша с помощью метода hgetall():"""
# conn.hgetall('song')  # {b'do': b'a deer', b're': b'about a deer', b'mi': b'a note to follow re'}
"""Создадим поле, если его ключ не существует, с помощью метода hsetnx():"""
# conn.hsetnx('song', 'fa', 'a note that rhymes with la')  # 1








