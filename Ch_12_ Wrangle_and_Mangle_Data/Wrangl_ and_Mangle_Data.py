import unicodedata

"""Все текстовые примеры до сих пор имели формат ASCII (American Standard Code for Information 
Interchange). Этот формат был определен в 1960-х годах. Основной единицей хранения информации был
байт, который мог хранить 256 уникальных значений в своих 8 битах. Unicode — это действующий 
международный стандарт, определяющий символы всех языков мира плюс математические и другие символы.
Еще и эмодзи! Unicode предоставляет уникальный номер каждому символу, независимо от платформы, 
программыи языка."""
# print(ord("♥"), chr(9892))
# for char in range(1, 10000):
#     print(f"symbol-{char}--> {chr(char)}")

"""Модуль unicodedata содержит функции, которые преобразуют символы в обоих направлениях:
- lookup() принимает не зависящее от регистра имя и возвращает символ Unicode;
- name() принимает символ Unicode и возвращает его имя в верхнем регистре."""

def unicode_test(value):
    """Принимает символ Unicode, ищет его имя, а затем ищет символ, соответствующий полученному
имени (он должен совпасть с оригинальным)"""
    name = unicodedata.name(value)
    value2 = unicodedata.lookup(name)
    print(f"{value=}, {name=}, {value2=}, {ord(value)}")
    # print('value="%s", name="%s", value2="%s"' % (value, name, value2))
# unicode_test("♥")   # value='♥', name='BLACK HEART SUIT', value2='♥', 9829
# unicode_test('§')   # value='§', name='SECTION SIGN', value2='§', 167
# unicode_test("☃")   # value='☃', name='SNOWMAN', value2='☃', 9731

"""UTF-8 — это стандартная текстовая кодировка для Python, Linux и HTML. Она охватывает 
множество символов, работает быстро и хорошо. Гораздо удобнее работать с кодировкой UTF-8, 
чем постоянно переключаться с одной кодировки на другую.
UTF-8 — динамическую схему кодирования. 
Она использует для символа Unicode от 1 до 4 байт:
- 1 байт для ASCII;
- 2 байта для большинства языков, основанных на латинице (но не кириллице);
- 3 байта для других основных языков;
- 4 байта для остальных языков, включая некоторые азиатские языки и символы."""

"""Кодирование
Вы кодируете строку байтами. Первый аргумент строковой функции encode() — это имя кодировки.
"""
snowman = '\u2603'
ds = snowman.encode('utf-8')
"""Функция len() возвращает число байтов — 3, поскольку ds является переменной bytes."""
# print(ds, len(ds))  # b'\xe2\x98\x83' 3 # было использовано три байта
"""Декодирование
Мы декодируем байтовые строки в текстовые строки Unicode. Когда мы получаем текст
из какого-то внешнего источника (файлов, баз данных, сайтов, сетевых API и т. д.),
он закодирован в виде байтовой строки. Самое сложное — узнать, какая кодировка
была использована, чтобы можно было декодировать и получить строку Unicode.
Проблема в следующем: ничто в байтовой строке не говорит нам о том, какая
кодировка была использована.
"""
place = 'caf\u00e9'
# print(place, type(place)        # café <class 'str'>
"""Закодируем ее в формат UTF-8 с помощью переменной bytes, которая называется place_bytes"""
place_bytes = place.encode('utf-8')
# print(place_bytes, type(place_bytes), len(place_bytes))   # b'caf\xc3\xa9' <class 'bytes'> 5
"""Обратите внимание на то, что переменная place_bytes содержит 5 байт. Первые
три такие же, как в ASCII (преимущество UTF-8), а последние два кодируют символ
'é'. Теперь декодируем эту байтовую строку обратно в строку Unicode"""
place2 = place_bytes.decode('utf-8')
# print(place2)   # café
"""Это сработало, поскольку мы закодировали и декодировали строку с помощью кодировки UTF-8."""


"""Мораль этой истории: по возможности используйте кодировку UTF-8. Она работает и 
поддерживается везде, она способна выразить любой символ Unicode, и с ее
помощью можно быстро кодировать и декодировать."""




