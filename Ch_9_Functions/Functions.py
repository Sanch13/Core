"""Чем меньше функция, тем лучше управление."""
"""Первый шаг к повторному использованию кода — создание функций. Функция — это именованный 
фрагмент кода, отделенный от других. Она может принимать любое количество любых входных 
параметров и возвращать любое количество любых результатов. С функцией можно сделать две вещи:
определить ее, указав ноль или больше параметров;
вызвать ее и получить ноль или больше результатов."""
"""Значения, которые вы передаете в функцию при вызове, называются аргументами. 
КОГДА ВЫ ВЫЗЫВАЕТЕ ФУНКЦИЮ С АРГУМЕНТАМИ, ЗНАЧЕНИЯ ЭТИХ АРГУМЕНТОВ КОПИРУЮТСЯ В СООТВЕТСТВУЮЩИЕ 
ПАРАМЕТРЫ ВНУТРИ ФУНКЦИЙ. Другими словами, значения вне функции называются аргументами, 
а значения внутри — параметрами.
Если функция не вызывает return явно, вызывающая сторона получит результат None
None — это специальное значение в Python, которое заполняет собой пустое место,
если функция ничего не возвращает. Оно не является булевым значением False, хоть
и похоже на него при проверке булевой переменной."""
"""Чтобы отличить None от булева значения False, используйте оператор is:"""
thing = None
# print(f"It's nothing" if thing is None else f"It's something")  # It's nothing

"""False, но это не то же самое, что None"""

def whatis(thing):
    if thing is None:
        print(thing, "is None")
    elif thing:
        print(thing, "is True")
    else:
        print(thing, "is False")

# whatis(None)      # None is None
# whatis(True)      # True is True
# whatis(False)     # False is False
# whatis(0)         # 0 is False
# whatis(0.0)       # 0.0 is False
# whatis('')        #  is False
# whatis("")        #  is False
# whatis('''''')    #  is False
# whatis(())        # () is False
# whatis([])        # [] is False
# whatis({})        # {} is False
# whatis(set())     # set() is False
# whatis(0.00001)   # 1e-05 is True
# whatis([0])       # [0] is True
# whatis([''])      # [''] is True
# whatis(' ')       #   is True
"""Наиболее распространенный тип аргументов — это позиционные аргументы, чьи значения 
копируются в соответствующие параметры по порядку.
Эта функция создает словарь из позиционных входных аргументов и возвращает его"""

def menu(wine, entree, dessert):
    return {'wine': wine, 'entree': entree, 'dessert': dessert}

menu('chardonnay', 'chicken', 'cake')
# {'wine': 'chardonnay', 'entree': 'chicken', 'dessert': 'cake'}
"""Для того чтобы избежать путаницы с позиционными аргументами, вы можете указать аргументы с 
помощью имен соответствующих параметров. Порядок следования аргументов в этом случае 
может быть иным"""
menu(entree='beef', dessert='bagel', wine='bordeaux')
# {'wine': 'bordeaux', 'entree': 'beef', 'dessert': 'bagel'}
"""Можно объединять позиционные аргументы и аргументы — ключевые слова. Сначала выберем вино, 
а для десерта и основного блюда используем аргументы — ключевые слова. Если вы вызываете функцию,
имеющую как позиционные аргументы, так и аргументы — ключевые слова, то позиционные
аргументы необходимо указывать первыми."""
menu('frontenac', dessert='flan', entree='fish')
# {'entree': 'fish', 'dessert': 'flan', 'wine': 'frontenac'}
"""В функции вы можете указать для параметров значения по умолчанию. Если вы предоставите аргумент, 
он будет использован вместо аргумента по умолчанию"""
"""Значение параметров по умолчанию высчитывается, когда функция определяется, а не выполняется. 
Распространенной ошибкой новичков (а иногда и не совсем новичков) является 
использование изменяемого типа данных, таких как список или словарь, 
в качестве параметра по умолчанию."""

def buggy(arg, result=[]):
    result.append(arg)
    print(result)

"""В следующей проверке функция buggy() каждый раз должна запускаться с новым пустым списком 
result, добавлять в него аргумент arg, а затем выводить на экран список, состоящий из одного 
элемента. Однако в этой функции есть баг: список пуст только при первом вызове. Во второй раз
список result будет содержать элемент, оставшийся после предыдущего вызова"""
# buggy('a')  # ['a']
# buggy('b')  #  ожидаем увидеть ['b'], but --> ['a', 'b']

"""Функция работала бы корректно, если бы код выглядел так"""

def works(arg):
    result = []
    result.append(arg)
    return result

works('a')   # ['a']
works('b')   # ['b']

"""Решить проблему можно, передав в функцию что-либо еще, указывающее на то, что вызов 
является первым"""

def nonbuggy(arg, result=None):
    if result is None:
        result = []
        result.append(arg)
        return result

nonbuggy('a')   # ['a']
nonbuggy('b')   # ['b']

"""Получаем/разбиваем аргументы — ключевые слова с помощью символа *. астериск (*) в Python. 
Если символ * будет использован внутри функции с параметром, произвольное количество 
позиционных аргументов сгруппируется в один кортеж. В следующем примере args 
является кортежем параметров, который был создан из нуля или более аргументов, 
переданных в функцию print_args().
"""

def print_args(*args):
    print('Positional argument tuple:', args)

"""Если вы вызовете функцию без аргументов, то получите пустой кортеж:"""
# print_args()    # Positional argument tuple: ()
"""Все аргументы, которые вы передадите, будут выведены на экран как кортеж args:"""
# print_args(3, 2, 1, 'wait!', 'uh...')   # Positional argument tuple: (3, 2, 1, 'wait!', 'uh...')
"""Это удобно при написании таких функций, как print(), которые принимают произвольное 
количество аргументов. Если в вашей функции имеются также обязательные позиционные аргументы,
поместите их в начало — *args отправится в конец списка и получит все остальные аргументы"""

def print_more(required1, required2, *args):
    print('Need this one:', required1)
    print('Need this one too:', required2)
    print('All the rest:', args)

# print_more('cap', 'gloves', 'scarf', 'monocle', 'mustache wax')
# Need this one: cap
# Need this one too: gloves
# All the rest: ('scarf', 'monocle', 'mustache wax')

"""При использовании * вам не нужно обязательно называть кортеж аргументов args, однако это 
распространенная идиома в Python. Также часто внутри функции используется конструкция *args,
как это показано в предыдущем примере, несмотря на то что технически она является 
параметром и должна называться *params. Символ * можно использовать только при описании 
функции и ее вызове"""
# print_args(2, 5, 7, 'x')    # Positional argument tuple: (2, 5, 7, 'x')
# args = (2,5,7,'x')
# print_args(args)            # Positional argument tuple: ((2, 5, 7, 'x'),)
# print_args(*args)           # Positional argument tuple: (2, 5, 7, 'x')

"""Получаем/разбиваем аргументы — ключевые слова с помощью символов ** Вы можете использовать 
два астериска (**), чтобы сгруппировать аргументы — ключевые слова в словарь, где имена 
аргументов станут ключами, а их значения — соответствующими значениями в словаре. 
В следующем примере определяется функция print_kwargs(), в которой выводятся 
ее аргументы — ключевые слова:"""

def print_kwargs(**kwargs):
    print('Keyword arguments:', kwargs)

# print_kwargs()  # Keyword arguments: {}
# print_kwargs(wine='merlot', entree='mutton', dessert='macaroon')
# Keyword arguments: {'wine': 'merlot', 'entree': 'mutton', 'dessert': 'macaroon'}
"""Внутри функции kwargs является параметром-словарем. Порядок аргументов будет следующим:
обязательные позиционные аргументы;
необязательные позиционные аргументы (*args);
необязательные аргументы — ключевые слова (**kwargs).
Как и в случае с args, вам не обязательно называть этот аргумент kwargs, однако такова
распространенная практика. Синтаксис ** можно применять только при вызове функции или
ее определении. Находясь за пределами функции, **kwargs разбивает 
словарь kwargs на аргументы в формате имя=значение. Находясь внутри функции, **kwargs собирает 
аргументы в формате имя=значение в словарь с именем kwargs."""

"""Изменяемые и неизменяемые аргументы Вы не забыли, что, если присвоить один список двум 
переменным, вы сможете изменить его, используя любую из этих переменных? И что это не 
сработает, если обе переменные ссылаются, например, на целое число или строку? Это происходит
потому, что список является изменяемым, а строка и целое число — нет. Вам нужно помнить про 
эту особенность при передаче аргументов в функцию. Если аргумент изменяемый, то его 
значение можно изменить изнутри функции с помощью соответствующего параметра"""
outside = ['one', 'fine', 'day']
def mangle(arg):
    arg[1] = 'terrible!'
# outside                 # ['one', 'fine', 'day']
mangle(outside)
# outside                 # ['one', 'terrible!', 'day']
"""Хорошим тоном считается умение избегать подобных ситуаций. Любой документ, 
являющийся аргументом, может измениться или вернуть новое значение."""

"""В Python генератор — это объект, который предназначен для создания последовательностей. 
С его помощью вы можете итерировать потенциально огромные последовательности, не создавая 
и не сохраняя всю последовательность в памяти сразу. Генераторы часто становятся 
источником данных для итераторов. Каждый раз, когда вы итерируете через генератор, 
он отслеживает, где находился во время последнего вызова, и возвращает следующее значение. 
Это отличает его от обычной функции, которая не помнит о предыдущих вызовах и всегда начинает
работу с первой строки в том же состоянии."""


"""Функции-генераторы. Если вы хотите создать потенциально большую последовательность, 
вы можете написать функцию-генератор. Это обычная функция, однако она возвращает значение
с помощью выражения yield, а не return."""

def my_range(first=0, last=10, step=1):
    number = first
    while number < last:
        yield number
        number += step

"""my_range обычная функция <function my_range at 0x10193e268>. 
И она возвращает объект генератора:"""
ranger = my_range(1, 5)  # ranger --> <generator object my_range at 0x00000193A94F0270>
"""Мы можем проитерировать по этому объекту генератора"""
# for x in ranger: print(x, end='')           # 1234
# for try_again in ranger: print(try_again)   # empty
"""Генератор можно запустить лишь однажды. Списки, множества, строки и словари 
существуют в памяти, а генераторы создают свои значения на лету и выдают их 
по одному с помощью итератора. Генератор не запоминает значения, поэтому вы 
не можете перезапустить его или создать резервную копию.
Если вы попробуете снова проитерировать по генератору, вы увидите, что он истощился
"""

"""Вы уже сталкивались с включениями списков, словарей и множеств. Включение 
генератора выглядит так же, но заключается в круглые скобки, а не в квадратные
или фигурные. Оно похоже на сокращенную функцию-генератор, которая неявно
выполняет yield и возвращает объект генератора:"""
genobj = (pair for pair in zip(['a', 'b'], ['1', '2']))  # ('a', '1') ('b', '2')

"""Декораторы
Иногда вам нужно модифицировать существующую функцию, не меняя при этом ее
исходный код. Чаще всего добавляется выражение для отладки, чтобы посмотреть,
какие аргументы были переданы.Декоратор — это функция, которая принимает одну функцию в 
качестве аргумента и возвращает другую функцию. Функция document_it() определяет декоратор, который:
- выведет имя функции и значения переданных в нее аргументов;
- запустит функцию с полученными аргументами;
- выведет результат;
- вернет модифицированную функцию, готовую для использования.
"""

def document_it(func):
    def function_1(*args, **kwargs):
        print('Running function:', func.__name__)
        print('Positional arguments:', args)
        print('Keyword arguments:', kwargs)
        result = func(*args, **kwargs)
        print('Result:', result)
        return result
    return function_1

"""Независимо от того, какую функцию func вы передадите document_it(), вы получите новую 
функцию с дополнительными выражениями, которые добавляет document_it(). Декоратор 
не обязательно должен запускать код функции func, но функция document_it() вызовет 
часть func, чтобы вы получили результат работы функции func, а также дополнительные данные:"""

# @document_it
# def add_ints(a, b):
#     return a + b

# add_ints(3, 5)  # 8
# cooler_add_ints = document_it(add_ints)(3, 5)  # создание декоратора вручную
# Running function: add_ints
# Positional arguments: (3, 5)
# Keyword arguments: {}
# Result: 8
# 8

"""В качестве альтернативы созданию декоратора вручную (этот процесс мы только
что рассмотрели) можно добавить конструкцию @имя_декоратора перед функцией,
которую нужно декорировать"""

# add_ints(3, 5)
# Running function: add_ints
# Positional arguments: (3, 5)
# Keyword arguments: {}
# Result: 8
# 8


"""У каждой функции может быть больше одного декоратора. Напишем еще один
с именем square_it(), который возводит результат в квадрат"""

def square_it(func):
    def function_2(*args, **kwargs):
        result = func(*args, **kwargs)
        return f"This is two decorate {result ** 2}"
    return function_2

"""Декоратор, размещенный ближе всего к функции (прямо над def), будет выполнен первым, а 
затем выполнится тот, что находится сразу над ним. Любой порядок вызова вернет один и тот 
же конечный результат, но вы можете увидеть все промежуточные этапы:"""

# @document_it
# @square_it
# def add_ints(a, b):
#     return a + b
#
# add_ints(3, 5)

"""Пространства имен и область определения. Имя может ссылаться на несколько разных объектов в
 зависимости от того, где оно используется. Программы на Python имеют различные пространства 
 имен — разделы, внутри которых определенное имя уникально и не связано с таким же именем
в других пространствах имен."""
"""В основной программе определяется глобальное пространство имен, поэтому
переменные, находящиеся в нем, являются глобальными. Значение глобальной переменной можно 
получить внутри функции:"""

animal = 'Dog'

def print_glodal():
    print('inside print_global:', animal)

# print('at the top level:', animal)  # at the top level: dog
# print_glodal()                      # inside print_global: dog

def change_local():
    animal = 'Wombat'
    print('inside change_local:', animal, id(animal))

# print(animal, id(animal))   # Dog 2451195080368
# change_local()              # inside change_local: Wombat 2451195080624

"""Чтобы получить доступ не к локальной переменной внутри функции, а к глобальной 
переменой, нужно явно использовать ключевое слово global (вы знали, что
я это скажу: явное лучше, чем неявное)"""

animal = 'fruitbat'
def change_and_print_global():
    global animal
    animal = 'wombat'
    print('inside change_and_print_global:', animal)

# print(animal)               # fruitbat
# change_and_print_global()   # inside change_and_print_global: wombat
# print(animal)               # wombat

"""Python предоставляет две функции для доступа к содержимому ваших пространств имен:
- locals() — возвращает словарь, содержащий имена локального пространства имен;
- globals() — возвращает словарь, содержащий имена глобального пространства имен."""

"""Рекурсия. Если функция вызывает саму себя - Это называется рекурсией. Рекурсия может быть 
полезна, если вы работаете с чем-то вроде списков, содержащих списки, которые содержат списки.
Предположим, вы хотите «уплотнить» все подсписки независимо от того, насколько глубоко они вложены. 
Для этого отлично подойдет функция-генератор:"""


def flatten(lol):                           # Функция-генератор
    for item in lol:                        # Итерируемся по списку
        if isinstance(item, list):          # Если объект явл. списком то переходим в констр. for
            for subitem in flatten(item):   # Теперь вызываем flatten и передаем список item
                yield subitem               # снова итерируемся по списку если не список вернет
        else:                               # число которое вернется через yield subitem
            yield item                  # Если объект не явл. списком то вернем объект yield item


lol = [1, 2, [3,4,5], [6,[7,8,9], []]]
list(flatten(lol))  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
"""В Python 3.3 появилось выражение yield from, которое позволяет генератору
передавать часть работы другому генератору. Мы можем использовать его для того,
чтобы упростить функцию flatten():"""


def flatten(lol):                           # Функция-генератор
    for item in lol:                        # Итерируемся по списку
        if isinstance(item, list):          # Если объект явл. списком то переходим к конструкции
            yield from flatten(item)        # yield from flatten(item) и передаем список item
                                            # снова итерируемся по списку если не список то вернет
        else:                               # число которое вернется через yield item
            yield item                  # Если объект не явл. списком то вернем объект yield item


"""Ключевые слова async и await были добавлены в Python 3.5 для того, чтобы можно
было определять и запускать асинхронные функции. , если вы в объявлении функции
перед словом def видите слово async, это значит, что функция асинхронная. Аналогично, если 
перед вызовом функции вы видите слово await, эта функция также является асинхронной. 
Основное различие между асинхронными и обычными функциями заключается в том, что 
асинхронные могут «передавать управление» вместо того, чтобы заставлять основной 
поток выполнения ждать до конца их выполнения"""


"""Исключения. В Python, если дело пахнет жареным, используется исключение: код, который 
выполняется, когда происходит связанная с ним ошибка. Когда вы выполняете код, который при 
определенных условиях может не сработать, вам также понадобятся обработчики исключений 
для перехвата любых потенциальных ошибок. Чтобы пользователь знал о происходящем, 
рекомендуется добавлять обработчики исключений везде, где исключение может быть сгенерировано. 
Не всегда у вас получится исправить ошибку, но вы хотя бы будете знать, при каких обстоятельствах
она появилась, и аккуратно завершите программу. Вместо того чтобы полагаться на волю случая, 
размещайте свой код в блоке try и используйте блок except для обработки ошибки"""

"""Заускается код внутри блока try. Если произошла ошибка, генерируется исключение и
выполняется код, расположенный внутри блока except. Если ошибок не произошло, блок 
except пропускается. Отсутствие аргументов в блоке except позволяет ловить исключения любого типа.
Если предполагается, что могут возникнуть несколько типов исключений, лучшим решением будет 
предоставить отдельный обработчик для каждого из них. Никто не заставляет это делать — 
можно использовать блок except без аргументов, но тогда обработка будет достаточно поверхностной
(что-то вроде вывода на экран строки Произошла ошибка). Разрешается использовать
любое количество обработчиков исключений."""

"""Иногда вам будут нужны и другие подробности исключения, а не только его тип.
Вы можете получить объект исключения целиком в переменной имя, если используете такую форму:
except тип_исключения as имя
"""
# short_list = [1, 2, 3]
# while True:
#     value = input('Position [q to quit]? ')
#     if value == 'q':
#         break
#     try:
#         position = int(value)
#         print(short_list[position])
#     except IndexError as err:
#         print('Bad index:', position)
#     except Exception as other:
#         print('Something else broke:', other)


"""Можете также и определять собственные типы исключений, чтобы обрабатывать особые ситуации, 
которые могут возникнуть в ваших программах. Для этого потребуется определить новый тип 
объекта с помощью класса. Любое исключение является классом, частным случаем класса Exception"""

# class UppercaseException(Exception):
#     pass
#
# words = ['eeenie', 'meenie', 'miny', 'MATHER']
# for word in words:
#     if word.isupper():
#         raise UppercaseException(word)

"""Мы даже не определяли какое-то поведение для UppercaseException (обратите внимание — мы 
просто использовали pass), позволив его родительскому классу Exception самостоятельно 
разобраться, что именно выводить на экран при генерации исключения."""

# TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS





###################################################################################################
"""9.1. Определите функцию good(), которая возвращает следующий список:
['Harry', 'Ron', 'Hermione']."""
def good():
    return ['Harry', 'Ron', 'Hermione']
# print(good()) # ['Harry', 'Ron', 'Hermione']
###################################################################################################
"""9.2. Определите функцию генератора get_odds(), которая возвращает нечетные числа из диапазона 
range(10). Используйте цикл for, чтобы найти и вывести третье возвращенное значение."""
def get_odds():
    for i in range(10):
        if i % 2 == 1:
            yield i

# list(get_odds())[2]  # 5 my version
# count = 1
# for number in get_odds():
#     if count == 3:
#         print("The third odd number is", number)    # 5
#         break
#     count += 1
###################################################################################################
"""9.3. Определите декоратор test, который выводит строку 'start' при вызове функции и строку 
'end', когда функция завершает свою работу."""


def test(func):
    def wrapper(*args, **kwargs):
        print('start')
        result = func(*args, **kwargs)
        print('end')
        return result
    return wrapper

@test
def func():
    return

# func()
###################################################################################################
class OopsException(Exception):
    pass

# raise OopsException()   # raise exception
# try:
#     raise OopsException()
# except OopsException:
#     print("Caught an oops")
