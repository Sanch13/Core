import string

"""TCP/IP
Интернет основан на правилах, по которым создаются соединения, идет обмен
данными, закрываются соединения, обрабатывается истечение срока действия и т. д.
Эти правила называются протоколами, и они упорядочены в слои. Примерно в середине находится IP
(Internet Protocol — интернет-протокол), на котором определяется, как
адресуются локации сети и перемещаются пакеты (фрагменты) данных. На слое,
расположенном выше IP, два протокола описывают, как перемещать байты между локациями
- UDP (User Datagram Protocol — протокол датаграмм пользователя). Служит для
обмена небольшим объемом данных. Датаграмма — это небольшое сообщение,
которое отправляется целиком; оно похоже на открытку. Для сообщений, отправляемых по протоколу UDP,
 подтверждение не требуется, поэтому вы никогда не можете быть уверены в том, что они придут
в точку назначения.
- TCP (Transmission Control Protocol — протокол управления передачей). Используется для более
длинных соединений. С его помощью отправляются потоки байтов, он гарантирует, что они придут по
порядку и без дупликаций. TCP устанавливает секретное рукопожатие между отправляющей и принимающей
стороной, чтобы гарантировать хорошее соединение.
    Ваша локальная машина всегда будет иметь IP-адрес 127.0.0.1 и имя localhost. При подключении к
Интернету у вашей машины также появится публичный IP. Если же вы используете домашний компьютер,
то он будет скрыт за оборудованием, таким как кабельный модем или роутер.
Сокеты
По протоколу UDP данные отправляются небольшими фрагментами. Этот протокол не гарантирует доставки.
Если вы отправите несколько сообщений с помощью UDP, то они могут прийти в неправильном порядке
или вообще не появиться. Этот протокол быстр, легок, не создает соединений, однако ненадежен
TCP 
(Transmission Control Protocol —протокол управления передачей).
Он используется для более продолжительных соединений, таких как соединения с Интернетом. TCP
доставляет данные в том порядке, в котором те были отправлены. Если возникают какие-то проблемы, то
он пытается отправить данные снова. Из-за этого протокол TCP работает немного медленнее, чем UDP,
но, как правило, он предпочтительнее, если вам нужно получить все пакеты в правильном порядке
- UDP отправляет сообщения, но их размер ограничен и нет гарантии, что они достигнут
    места назначения.
- TCP вместо сообщений отправляет потоки байтов. Вы не знаете, сколько байтов отправит или 
    получит система с каждым вызовом.
- Для обмена сообщениями с помощью TCP вам нужна дополнительная информация, чтобы собрать полное 
    сообщение из сегментов: фиксированный размер сообщения (в байтах), или размер всего сообщения,
    или какой-либо разделитель.
- Поскольку сообщения являются байтами, а не текстовыми строками Unicode, вам придется использовать
    тип bytes.
scapy
Иногда вам нужно погрузиться в поток данных, путешествующих по сети. Возможно, вы хотите отладить
веб-API или отследить некую проблему безопасности. Библиотека scapy и программа предоставляют 
предметно-ориентированный язык для создания и анализа пакетов в Python. Документация 
(https://scapy.readthedocs.io/) этой библиотеки довольно обширна.
Netcat
Еще один инструмент для проверки сетей и портов — Netcat (https://oreil.ly/K37H2),
название которого зачастую сокращают до nc.
Паттерн «Запрос — ответ»
Этот паттерн самый распространенный. Вы запрашиваете данные о DNS, сети или
электронной почте у соответствующих серверов, и они либо возвращают ответ, либо
сообщают о проблеме.
ZeroMQ
ZeroMQ — библиотека, а не сервер. Иногда называемые сокетами на стероидах, сокеты ZeroMQ делают то,
чего вы вроде бы ожидаете от обычных сокетов:
- происходит обмен сообщениями целиком;
- выполняются повторные соединения при обрыве;
- выполняется буферизация данных для их сохранения в том случае, когда отправители и получатели
не синхронизированы
Онлайн-руководство (http://zguide.zeromq.org/) написано хорошим языком, в нем
представлено лучшее из виденных мной описаний сетевых паттернов. типы сокетов ZeroMQ
- REQ (синхронный запрос);
- REP (синхронный ответ);
- DEALER (асинхронный запрос);
- ROUTER (асинхронный ответ);
- PUB (публикация);
- SUB (подписка);
- PUSH (разветвление на выходе);
- PULL (разветвление на входе).
"""
# import zmq
# zmq_server.py
# host = '127.0.0.1'
# port = 6789
# context = zmq.Context()
# server = context.socket(zmq.REP)
# server.bind(f"tcp://{host}:{port}")
# while True:
#     # ожидаем следующего запроса клиента
#     request_bytes = server.recv()
#     request_str = request_bytes.decode('utf-8')
#     print(f"That voice in my head says: {request_str}")
#     reply_str = f"Stop saying: {request_str}"
#     reply_bytes = bytes(reply_str, 'utf-8')
#     server.send(reply_bytes)
#
# zmq_client.py
# host = '127.0.0.1'
# port = 6789
# context = zmq.Context()
# server = context.socket(zmq.REP)
# server.bind(f"tcp://{host}:{port}")
# while True:
#     # ожидаем следующего запроса клиента
#     request_bytes = server.recv()
#     request_str = request_bytes.decode('utf-8')
#     print(f"That voice in my head says: {request_str}")
#     reply_str = f"Stop saying: {request_str}"
#     reply_bytes = bytes(reply_str, 'utf-8')
#     server.send(reply_bytes)

"""Наш клиент завершает работу после отправки пятого сообщения, но мы не давали такого указания
серверу, поэтому он будет ожидать новых сообщений. При повторном запуске клиент выведет те же
пять строк, сервер тоже выведет их. Если вы не завершите процесс zmq_server.py и попробуете
запустить еще один, то Python пожалуется на то, что адрес уже используется"""
# zmq.error.ZMQError: Address already in use
"""Сообщения нужно отправлять как байтовые строки, поэтому в нашем примере мы закодировали строки
в формате UTF-8. Вы можете отправить любое количество сообщений, если будете преобразовывать их 
в тип bytes. Мы использовали простые текстовые строки как источник сообщений, поэтому методов
encode() и decode() будет достаточно для трансформации их в байтовые строки и обратно. Если ваши
сообщения имеют другие типы данных, то можете использовать библиотеку, такую
как MessagePack (http://msgpack.org/).
    Любое количество клиентов REQ может использовать метод connect(), чтобы соединиться с
единственным сервером REP. Сервер обрабатывает запросы синхронно по одному за раз, но не сбрасывает
другие запросы, ожидающие его внимания. ZeroMQ буферизует сообщения до определенного
лимита; как раз из-за этого в его имени есть буква Q. Здесь она расшифровывается как 
Queue — «очередь», M — Message («сообщение»), а Zero («ноль») означает, что ему не нужны посредники.
"""
"""Другие инструменты обмена сообщениями
ZeroMQ определенно не единственная библиотека, отвечающая за передачу сообщений, которая
поддерживается Python. Передача сообщений — это одна из самых популярных идей в работе с сетями,
и Python старается соответствовать другим языкам программирования:
- проект Apache, чей веб-сервер вы увидите в подразделе «Apache» на с. 411, также
поддерживает проект ActiveMQ (https://activemq.apache.org/), который включает
несколько интерфейсов Python, использующих простой текстовый протокол
STOMP (https://oreil.ly/a3h_M);
- популярна также библиотека RabbitMQ (http://www.rabbitmq.com/), вы можете
прочесть онлайн-руководство для нее (http://bit.ly/rabbitmq-tut);
- NATS (http://www.nats.io/) — это быстрая система обмена сообщениями, написанная на Go."""

"""Другие инструменты «Публикации — подписки»
Вам могут пригодиться следующие ссылки Python.
- RabbitMQ — широко известный посредник сообщений, Python API для него называется pika. 
Обратитесь к тематической документации (http://pika.readthedocs.org/)
и руководству по «Публикации — подписке» (http://bit.ly/pub-sub-tut).
- Перейдите в окно поиска PyPi (https://pypi.python.org/) и введите pubsub, чтобы
найти пакеты для Python, такие как pypubsub (http://pubsub.sourceforge.net/).
- Протокол PubSubHubbub (https://code.google.com/p/pubsubhubbub) позволяет подписчикам 
зарегистрировать функции обратного вызова для публикаторов.
- NATS (https://nats.io/) — это быстрая система обмена сообщениями с открытым
исходным кодом, которая поддерживает паттерны «Публикация — подписка»,
«Запрос — ответ» и очереди.

Интернет-сервисы
Python имеет широкий набор инструментов для работы с сетями. В следующих подразделах мы рассмотрим 
способы автоматизации наиболее популярных интернет-сервисов. В сети доступна полная официальная
 документация (http://bit.ly/py-internet)."""

"""Доменная система имен
Компьютеры имеют числовые IP-адреса, например 85.2.101.94, однако имена
мы запоминаем лучше, чем числа. Доменная система имен (Domain Name System,
DNS) — критически важный интернет-сервис, который преобразует IP-адреса
в имена и обратно с помощью распределенной базы данных."""

"""Некоторые номера портов для TCP и UDP (http://bit.ly/tcp-udp-ports) зарезервированы
определенными сервисами IANA и связаны с именами сервисов. Например,
HTTP имеет имя http, ему присвоен номер порта TCP 80."""

"""Веб-сервисы и API
Поставщики информации всегда имеют сайт, однако он предназначен для человеческих глаз, а не
для машин. сайт предлагает API для своих данных, то эти данные становятся доступными для
клиентских программ. API меняются реже, чем макеты веб-страниц, поэтому и изменения в клиентах 
распространены меньше. Быстрый чистый конвейер также позволяет упростить создание гибридных
приложений — комбинаций, которые не предвиделись, но могут быть полезны и даже прибыльны.
Простейший API — веб-интерфейс, который предоставляет данные в структурированном формате,
таком как JSON или XML (однако не в текстовом и не в формате HTML). API может быть минимальным
или полнофункциональным RESTful API. Все сайты предоставляют бесплатные API, но требуют от вас 
регистрации и получения ключа (долго генерируемой текстовой строки, ее часто называют токеном), 
который будет использоваться при соединении. Ключ помогает сайту определить, кто получает
доступ к данным. Он также может служить для ограничения трафика запросов к серверам.
"""

"""Сериализация данных
такие форматы данных, как XML, JSON и YAML, представляют собой способы хранения структурированных
текстовых данных. Сетевым приложениям необходимо обмениваться данными с другими программами. 
Преобразование между данными в памяти и последовательностями байтов (в частности, перед их
отправкой другому клиенту) называется сериализацией или маршаллингом. JSON — это популярный формат
сериализации, особенно часто используемый в RESTful-системах, но с его помощью нельзя выразить
все типы данных, используемые в Python. Кроме того, как текстовый формат он выглядит более
многословным в отличие от ряда бинарных методов сериализации. 
"""

"""Сериализация с помощью pickle
Python предоставляет модуль pickle, позволяющий сохранить и восстановить любой
объект в специальном бинарном формате."""
import pickle
import datetime
now = datetime.datetime.now()
pickled = pickle.dumps(now)
out_now = pickle.loads(pickled)
# print(type(pickled))    # <class 'bytes'>
# print(out_now)  2022-10-05 19:40:55.180189
"""Модуль pickle работает и с вашими классами и объектами."""
class Tiny():
    def __str__(self):
        return 'tiny'

obj = Tiny()
# print(type(obj), str(obj))    # <class '__main__.Tiny'> tiny
pickled_1 = pickle.dumps(obj)
"""Строка pickled_1 — это обработанная pickle бинарная строка, созданная из объекта obj"""
# print(pickled_1)
# b'\x80\x04\x95\x18\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x04Tiny\x94\x93\x94)\x81\x94.'
obj2 = pickle.loads(pickled_1)
"""Используйте функцию dump(), чтобы pickle сохранил данные в файл, и функцию load(), 
чтобы pickle загрузил данные из файла."""
# print(obj2)  # tiny
"""Если модуль pickle не может сериализовать ваш формат данных, то с ним, возможно, справится
более новый сторонний пакет dill (https://pypi.org/project/dill)."""

"""Другие форматы сериализации
Есть и другие бинарные форматы обмена данными, они обычно компактнее и быстрее, чем XML или JSON:
- MsgPack (http://msgpack.org/);
- Protocol Buffers (https://code.google.com/p/protobuf);
- Avro (http://avro.apache.org/docs/current);
- Thrift (http://thrift.apache.org/);
- Lima (https://lima.readthedocs.io/);
- Serialize (https://pypi.org/project/Serialize) — это фронтенд Python для других форматов,
    включающих JSON, YAML, pickle и MsgPack;
- Бенчмарк (https://oreil.ly/S3ESH) различных пакетов сериализации для Python.
Поскольку они бинарные, ни один из них не может быть изменен человеком, вооружившимся текстовым
редактором. Некоторые сторонние пакеты выполняют двухстороннюю конвертацию объектов
и простых типов данных Python (что позволяет преобразовывать их в такие форматы, как JSON), 
а также могут выполнять валидацию таких категорий:
- типы данных;
- диапазоны значений;
- обязательные и необязательные данные.
Ниже представлены некоторые из этих пакетов:
- Marshmallow (https://marshmallow.readthedocs.io/en/3.0);
- Pydantic (https://pydantic-docs.helpmanual.io/) — использует подсказки для типов,
поэтому требует версии Python не ниже 3.6;
- TypeSystem (https://www.encode.io/typesystem).
Эти пакеты зачастую используются вместе с веб-серверами для гарантии того,
что байты, которые попали к ним по протоколу HTTP, отправятся в правильные
структуры данных для дальнейшей обработки."""

"""Удаленные вызовы процедур
Удаленные вызовы процедур (Remote Procedure Call, RPC) выглядят как обычные
функции, но выполняются на удаленных машинах по всей сети. Вместо того чтобы
вызывать RESTful API и передавать туда аргументы, закодированные в URL или
теле запросов, вы можете вызвать функцию RPC на собственной машине. При этом
в RPC-клиенте произойдет следующее.
1. Он преобразует аргументы вашей функции в байты.
2. Он отправляет закодированные байты удаленной машине.
И вот что происходит на удаленной машине.
1. Она получает закодированные байты запроса.
2. После получения байтов RPC-клиент декодирует их в оригинальные структуры
данных.
3. Затем клиент находит и вызывает локальную функцию с помощью раскодированных данных.
4. Далее он кодирует результат работы функции.
5. Наконец, отправляет закодированные байты вызывающей стороне.
Затем машина, запустившая процесс, декодирует полученные байты в возвращенные значения.
RPC — это популярный прием, и люди реализовали его множеством способов.
На стороне сервера вы запускаете серверную программу, создаете механизм для
ее связывания с помощью какого-либо способа транспортировки байтов и метода
кодирования/декодирования, определяете функции сервиса и подаете сигнал «RPC 
готов к работе». Клиенты соединяются с сервером и вызывают одну из его функций
с помощью RPC"""

"""XML RPC
Стандартная библиотека содержит только одну реализацию RPC, которая использует в качестве формата
обмена данными XML, — xmlrpc. Вы определяете и регистрируете функции на сервере, а клиент вызывает
их так, будто они были импортированы. Сначала рассмотрим файл xmlrpc_server.py 
Функция, которую мы предоставляем на сервере, называется double(). В качестве аргумента она ожидает
число, а возвращает его же, умноженное на два. Сервер начинает работу на определенных адресе и
порте. Нам нужно зарегистрировать функцию, чтобы сделать ее доступной клиентам с помощью RPC.
Наконец, можно запустить ее.
рассмотрим файл xmlrpc_client.py.
Клиент соединяется с сервером с помощью функции ServerProxy(). Далее он
вызывает функцию proxy.double(). Откуда она появилась? Она была создана динамически с помощью 
сервера. Механизм RPC волшебным образом прикрепляет имя функции к вызову удаленного сервера.
"""

"""JSON RPC
JSON-RPC (версии 1.0 (https://oreil.ly/OklKa) и 2.0 (https://oreil.ly/4CS0r)) аналогичны
XML-RPC, но в них используется JSON. Существует множество библиотек для работы с JSON-RPC, самая
простая из них состоит из двух частей: клиента 
(https://oreil.ly/8npxf) и сервера (https://oreil.ly/P_uDr)."""

"""MessagePack RPC
Библиотека кодирования MessagePack имеет собственную реализацию RPC (http://bit.ly/msgpack-rpc)
Эта команда также установит tornado, веб-сервер, основанный на событиях, который данная библиотека
использует в качестве транспорта. сервер msgpack_server.py. клиент, msgpack_client.py.
Класс Services предоставляет свои методы как сервисы RPC.
"""

"""Инструменты удаленного управления
- Salt (http://www.saltstack.com/) написан на Python. Он создавался как способ реализовать 
удаленное выполнение программ, но позже вырос в полноценную платформу управления системами. 
Основанный на ZeroMQ вместо SSH, он может
работать с тысячами серверов.
- Альтернативными продуктами являются Puppet (http://puppetlabs.com/) и Chef
(http://www.getchef.com/chef), тесно связанные с Ruby.
- Пакет Ansible (http://www.ansible.com/home), который, как и Salt, написан с помощью Python, 
вполне сопоставим с ними. Вы можете скачать и применять его бесплатно, но поддержка и отдельные
пакеты с надстройками требуют коммерческой лицензии. По умолчанию он использует SSH и не 
требует установки особого программного обеспечения на тех компьютерах, которыми будет управлять.
Пакеты Salt и Ansible функционально являются супермножествами пакета
Fabric, поскольку обрабатывают исходную конфигурацию, развертывание и удаленное выполнение."""

"""Работаем с большими объемами данных
Разработчики обнаружили, что гораздо быстрее было распространять и анализировать данные на 
нескольких объединенных в сеть машинах, чем на отдельных.
Они могли использовать алгоритмы, которые звучали просто, однако на деле в целом
лучше работали с объемными распределенными данными. Один из таких алгоритмов
называется MapReduce, он может распределить вычисления между несколькими
компьютерами и затем собрать результат. Это похоже на работу с очередями.
"""

"""Hadoop
Здесь вступают в действие слова «большие данные». Для некоторых организаций решением
вопроса больших данных является Hadoop. Этот пакет копирует данные среди машин, пропускает их
через программы масштабирования и сжатия и сохраняет на диск результаты после каждого шага.
Более быстрый метод — отправка потоком с помощью Hadoop, который работает как каналы Unix, посылая
данные между программами и не требуя записи на диск после выполнения каждого шага. Вы можете
писать программы, использующие отправку потоком с помощью Hadoop, на любом языке, включая Python.
"""

"""Spark
Конкурент по имени Spark (http://bit.ly/about-spark) был разработан для того, чтобы
превысить скорость работы Hadoop в 10–100 раз. Он может читать и обрабатывать
любой источник данных и формат Hadoop. Spark включает в себя API для Python
и других языков. Вы можете найти документацию по установке онлайн (http://bit.ly/dl-spark)."""

"""Docker
Простой стандартизированный контейнер отправки ПО произвел революцию в международной торговле. 
Всего несколько лет назад Docker применил название «контейнер» и аналогию к методу виртуализации
с помощью малоизвестных особенностей Linux. Контейнеры гораздо легче, чем виртуальные машины, и 
немного тяжелее, чем virtualenvs в Python. Они позволяют упаковать приложение отдельно от других
программ на одной и той же машине, общим для них будет только ядро ОС.
Чтобы установить клиентскую библиотеку Docker (https://pypi.org/project/docker),
выполните следующую команду"""

"""Kubernetes
Технология контейнеризации распространилась по всему вычислительному миру.
В конечном счете возникла потребность в способе управления большим количеством контейнеров и 
автоматизации операций, выполняемых вручную в крупных распределенных системах:
- обход отказов;
- нагрузки;
- масштабирование.
Похоже, что лидером на рынке управления контейнерами становится Kubernetes
(https://kubernetes.io/).
Чтобы установить его клиентскую библиотеку (https://github.com/kubernetes-client/python)"""


# TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS
"""17.1. Используйте объект класса socket, чтобы реализовать сервис, сообщающий текущее время. 
Когда клиент отправляет на сервер строку 'time', верните текущие дату и время как строку ISO.
Смотрите файлы tasks_17_1"""
###################################################################################################
"""17.2. Задействуйте сокеты ZeroMQ REQ и REP, чтобы сделать то же самое. Смотрите файлы 
tasks_17_2"""
###################################################################################################
"""17.3. Попробуйте сделать то же самое с помощью XMLRPC. Смотрите файлы tasks_17_3"""
###################################################################################################
"""17.4. Возможно, вы видели эпизод телесериала I Love Lucy, в котором Люси и Этель
работают на шоколадной фабрике. Парочка стала отставать, когда линия конвейера, направлявшая к 
ним на обработку конфеты, еще более ускорилась. Напишите симуляцию, которая отправляет разные типы
конфет в список Redis, и клиент Lucy, делающий блокирующие выталкивания из списка.
Ей нужно 0,5 секунды, чтобы обработать одну конфету. Выведите на экран время и тип каждой конфеты,
которую получит Lucy, а также количество необработанных конфет. Смотрите файлы tasks_17_4"""
###################################################################################################
"""17.5. Используйте ZeroMQ, чтобы публиковать стихотворение из упражнения 12.4 (пример 12.1) по
одному слову за раз. Напишите потребитель ZeroMQ, который будет выводить на экран каждое слово, 
начинающееся с гласной. Знаки препинания игнорируйте. Смотрите файлы tasks_17_5"""
###################################################################################################
"""17.6. Напишите другой потребитель, который станет выводить все слова, состоящие из пяти букв. 
Смотрите файлы tasks_17_6"""




