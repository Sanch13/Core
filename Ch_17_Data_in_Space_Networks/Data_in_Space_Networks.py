import string

"""TCP/IP
Интернет основан на правилах, по которым создаются соединения, идет обмен
данными, закрываются соединения, обрабатывается истечение срока действия и т. д.
Эти правила называются протоколами, и они упорядочены в слои. Примерно в середине находится IP
(Internet Protocol — интернет-протокол), на котором определяется, как
адресуются локации сети и перемещаются пакеты (фрагменты) данных. На слое,
расположенном выше IP, два протокола описывают, как перемещать байты между локациями
- UDP (User Datagram Protocol — протокол датаграмм пользователя). Служит для
обмена небольшим объемом данных. Датаграмма — это небольшое сообщение,
которое отправляется целиком; оно похоже на открытку. Для сообщений, отправляемых по протоколу UDP,
 подтверждение не требуется, поэтому вы никогда не можете быть уверены в том, что они придут
в точку назначения.
- TCP (Transmission Control Protocol — протокол управления передачей). Используется для более
длинных соединений. С его помощью отправляются потоки байтов, он гарантирует, что они придут по
порядку и без дупликаций. TCP устанавливает секретное рукопожатие между отправляющей и принимающей
стороной, чтобы гарантировать хорошее соединение.
    Ваша локальная машина всегда будет иметь IP-адрес 127.0.0.1 и имя localhost. При подключении к
Интернету у вашей машины также появится публичный IP. Если же вы используете домашний компьютер,
то он будет скрыт за оборудованием, таким как кабельный модем или роутер.
Сокеты
По протоколу UDP данные отправляются небольшими фрагментами. Этот протокол не гарантирует доставки.
Если вы отправите несколько сообщений с помощью UDP, то они могут прийти в неправильном порядке
или вообще не появиться. Этот протокол быстр, легок, не создает соединений, однако ненадежен
TCP 
(Transmission Control Protocol —протокол управления передачей).
Он используется для более продолжительных соединений, таких как соединения с Интернетом. TCP
доставляет данные в том порядке, в котором те были отправлены. Если возникают какие-то проблемы, то
он пытается отправить данные снова. Из-за этого протокол TCP работает немного медленнее, чем UDP,
но, как правило, он предпочтительнее, если вам нужно получить все пакеты в правильном порядке
- UDP отправляет сообщения, но их размер ограничен и нет гарантии, что они достигнут
    места назначения.
- TCP вместо сообщений отправляет потоки байтов. Вы не знаете, сколько байтов отправит или 
    получит система с каждым вызовом.
- Для обмена сообщениями с помощью TCP вам нужна дополнительная информация, чтобы собрать полное 
    сообщение из сегментов: фиксированный размер сообщения (в байтах), или размер всего сообщения,
    или какой-либо разделитель.
- Поскольку сообщения являются байтами, а не текстовыми строками Unicode, вам придется использовать
    тип bytes.
scapy
Иногда вам нужно погрузиться в поток данных, путешествующих по сети. Возможно, вы хотите отладить
веб-API или отследить некую проблему безопасности. Библиотека scapy и программа предоставляют 
предметно-ориентированный язык для создания и анализа пакетов в Python. Документация 
(https://scapy.readthedocs.io/) этой библиотеки довольно обширна.
Netcat
Еще один инструмент для проверки сетей и портов — Netcat (https://oreil.ly/K37H2),
название которого зачастую сокращают до nc.
Паттерн «Запрос — ответ»
Этот паттерн самый распространенный. Вы запрашиваете данные о DNS, сети или
электронной почте у соответствующих серверов, и они либо возвращают ответ, либо
сообщают о проблеме.
ZeroMQ
ZeroMQ — библиотека, а не сервер. Иногда называемые сокетами на стероидах, сокеты ZeroMQ делают то,
чего вы вроде бы ожидаете от обычных сокетов:
- происходит обмен сообщениями целиком;
- выполняются повторные соединения при обрыве;
- выполняется буферизация данных для их сохранения в том случае, когда отправители и получатели
не синхронизированы
Онлайн-руководство (http://zguide.zeromq.org/) написано хорошим языком, в нем
представлено лучшее из виденных мной описаний сетевых паттернов. типы сокетов ZeroMQ
- REQ (синхронный запрос);
- REP (синхронный ответ);
- DEALER (асинхронный запрос);
- ROUTER (асинхронный ответ);
- PUB (публикация);
- SUB (подписка);
- PUSH (разветвление на выходе);
- PULL (разветвление на входе).
"""
# import zmq
# zmq_server.py
# host = '127.0.0.1'
# port = 6789
# context = zmq.Context()
# server = context.socket(zmq.REP)
# server.bind(f"tcp://{host}:{port}")
# while True:
#     # ожидаем следующего запроса клиента
#     request_bytes = server.recv()
#     request_str = request_bytes.decode('utf-8')
#     print(f"That voice in my head says: {request_str}")
#     reply_str = f"Stop saying: {request_str}"
#     reply_bytes = bytes(reply_str, 'utf-8')
#     server.send(reply_bytes)
#
# zmq_client.py
# host = '127.0.0.1'
# port = 6789
# context = zmq.Context()
# server = context.socket(zmq.REP)
# server.bind(f"tcp://{host}:{port}")
# while True:
#     # ожидаем следующего запроса клиента
#     request_bytes = server.recv()
#     request_str = request_bytes.decode('utf-8')
#     print(f"That voice in my head says: {request_str}")
#     reply_str = f"Stop saying: {request_str}"
#     reply_bytes = bytes(reply_str, 'utf-8')
#     server.send(reply_bytes)

"""Наш клиент завершает работу после отправки пятого сообщения, но мы не давали такого указания
серверу, поэтому он будет ожидать новых сообщений. При повторном запуске клиент выведет те же
пять строк, сервер тоже выведет их. Если вы не завершите процесс zmq_server.py и попробуете
запустить еще один, то Python пожалуется на то, что адрес уже используется"""
# zmq.error.ZMQError: Address already in use
"""Сообщения нужно отправлять как байтовые строки, поэтому в нашем примере мы закодировали строки
в формате UTF-8. Вы можете отправить любое количество сообщений, если будете преобразовывать их 
в тип bytes. Мы использовали простые текстовые строки как источник сообщений, поэтому методов
encode() и decode() будет достаточно для трансформации их в байтовые строки и обратно. Если ваши
сообщения имеют другие типы данных, то можете использовать библиотеку, такую
как MessagePack (http://msgpack.org/).
    Любое количество клиентов REQ может использовать метод connect(), чтобы соединиться с
единственным сервером REP. Сервер обрабатывает запросы синхронно по одному за раз, но не сбрасывает
другие запросы, ожидающие его внимания. ZeroMQ буферизует сообщения до определенного
лимита; как раз из-за этого в его имени есть буква Q. Здесь она расшифровывается как 
Queue — «очередь», M — Message («сообщение»), а Zero («ноль») означает, что ему не нужны посредники.
"""
"""Другие инструменты обмена сообщениями
ZeroMQ определенно не единственная библиотека, отвечающая за передачу сообщений, которая
поддерживается Python. Передача сообщений — это одна из самых популярных идей в работе с сетями,
и Python старается соответствовать другим языкам программирования:
- проект Apache, чей веб-сервер вы увидите в подразделе «Apache» на с. 411, также
поддерживает проект ActiveMQ (https://activemq.apache.org/), который включает
несколько интерфейсов Python, использующих простой текстовый протокол
STOMP (https://oreil.ly/a3h_M);
- популярна также библиотека RabbitMQ (http://www.rabbitmq.com/), вы можете
прочесть онлайн-руководство для нее (http://bit.ly/rabbitmq-tut);
- NATS (http://www.nats.io/) — это быстрая система обмена сообщениями, написанная на Go."""

"""Другие инструменты «Публикации — подписки»
Вам могут пригодиться следующие ссылки Python.
- RabbitMQ — широко известный посредник сообщений, Python API для него называется pika. 
Обратитесь к тематической документации (http://pika.readthedocs.org/)
и руководству по «Публикации — подписке» (http://bit.ly/pub-sub-tut).
- Перейдите в окно поиска PyPi (https://pypi.python.org/) и введите pubsub, чтобы
найти пакеты для Python, такие как pypubsub (http://pubsub.sourceforge.net/).
- Протокол PubSubHubbub (https://code.google.com/p/pubsubhubbub) позволяет подписчикам 
зарегистрировать функции обратного вызова для публикаторов.
- NATS (https://nats.io/) — это быстрая система обмена сообщениями с открытым
исходным кодом, которая поддерживает паттерны «Публикация — подписка»,
«Запрос — ответ» и очереди.

Интернет-сервисы
Python имеет широкий набор инструментов для работы с сетями. В следующих подразделах мы рассмотрим 
способы автоматизации наиболее популярных интернет-сервисов. В сети доступна полная официальная
 документация (http://bit.ly/py-internet)."""

"""Доменная система имен
Компьютеры имеют числовые IP-адреса, например 85.2.101.94, однако имена
мы запоминаем лучше, чем числа. Доменная система имен (Domain Name System,
DNS) — критически важный интернет-сервис, который преобразует IP-адреса
в имена и обратно с помощью распределенной базы данных."""

"""Некоторые номера портов для TCP и UDP (http://bit.ly/tcp-udp-ports) зарезервированы
определенными сервисами IANA и связаны с именами сервисов. Например,
HTTP имеет имя http, ему присвоен номер порта TCP 80."""

"""Веб-сервисы и API
Поставщики информации всегда имеют сайт, однако он предназначен для человеческих глаз, а не
для машин. сайт предлагает API для своих данных, то эти данные становятся доступными для
клиентских программ. API меняются реже, чем макеты веб-страниц, поэтому и изменения в клиентах 
распространены меньше. Быстрый чистый конвейер также позволяет упростить создание гибридных
приложений — комбинаций, которые не предвиделись, но могут быть полезны и даже прибыльны.
Простейший API — веб-интерфейс, который предоставляет данные в структурированном формате,
таком как JSON или XML (однако не в текстовом и не в формате HTML). API может быть минимальным
или полнофункциональным RESTful API. Все сайты предоставляют бесплатные API, но требуют от вас 
регистрации и получения ключа (долго генерируемой текстовой строки, ее часто называют токеном), 
который будет использоваться при соединении. Ключ помогает сайту определить, кто получает
доступ к данным. Он также может служить для ограничения трафика запросов к серверам.
"""

"""Сериализация данных
такие форматы данных, как XML, JSON и YAML, представляют собой способы хранения структурированных
текстовых данных. Сетевым приложениям необходимо обмениваться данными с другими программами. 
Преобразование между данными в памяти и последовательностями байтов (в частности, перед их
отправкой другому клиенту) называется сериализацией или маршаллингом. JSON — это популярный формат
сериализации, особенно часто используемый в RESTful-системах, но с его помощью нельзя выразить
все типы данных, используемые в Python. Кроме того, как текстовый формат он выглядит более
многословным в отличие от ряда бинарных методов сериализации. 
"""

"""Сериализация с помощью pickle
Python предоставляет модуль pickle, позволяющий сохранить и восстановить любой
объект в специальном бинарном формате."""
import pickle
import datetime
now = datetime.datetime.now()
pickled = pickle.dumps(now)
out_now = pickle.loads(pickled)
# print(type(pickled))    # <class 'bytes'>
# print(out_now)  2022-10-05 19:40:55.180189
"""Модуль pickle работает и с вашими классами и объектами."""
class Tiny():
    def __str__(self):
        return 'tiny'

obj = Tiny()
# print(type(obj), str(obj))    # <class '__main__.Tiny'> tiny
pickled_1 = pickle.dumps(obj)
"""Строка pickled_1 — это обработанная pickle бинарная строка, созданная из объекта obj"""
# print(pickled_1)
# b'\x80\x04\x95\x18\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x04Tiny\x94\x93\x94)\x81\x94.'
obj2 = pickle.loads(pickled_1)
"""Используйте функцию dump(), чтобы pickle сохранил данные в файл, и функцию load(), 
чтобы pickle загрузил данные из файла."""
# print(obj2)  # tiny
"""Если модуль pickle не может сериализовать ваш формат данных, то с ним, возможно, справится
более новый сторонний пакет dill (https://pypi.org/project/dill)."""

"""Другие форматы сериализации
Есть и другие бинарные форматы обмена данными, они обычно компактнее и быстрее, чем XML или JSON:
- MsgPack (http://msgpack.org/);
- Protocol Buffers (https://code.google.com/p/protobuf);
- Avro (http://avro.apache.org/docs/current);
- Thrift (http://thrift.apache.org/);
- Lima (https://lima.readthedocs.io/);
- Serialize (https://pypi.org/project/Serialize) — это фронтенд Python для других форматов,
    включающих JSON, YAML, pickle и MsgPack;
- Бенчмарк (https://oreil.ly/S3ESH) различных пакетов сериализации для Python.
Поскольку они бинарные, ни один из них не может быть изменен человеком, вооружившимся текстовым
редактором. Некоторые сторонние пакеты выполняют двухстороннюю конвертацию объектов
и простых типов данных Python (что позволяет преобразовывать их в такие форматы, как JSON), 
а также могут выполнять валидацию таких категорий:
- типы данных;
- диапазоны значений;
- обязательные и необязательные данные.
Ниже представлены некоторые из этих пакетов:
- Marshmallow (https://marshmallow.readthedocs.io/en/3.0);
- Pydantic (https://pydantic-docs.helpmanual.io/) — использует подсказки для типов,
поэтому требует версии Python не ниже 3.6;
- TypeSystem (https://www.encode.io/typesystem).
Эти пакеты зачастую используются вместе с веб-серверами для гарантии того,
что байты, которые попали к ним по протоколу HTTP, отправятся в правильные
структуры данных для дальнейшей обработки."""












