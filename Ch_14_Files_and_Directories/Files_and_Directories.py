import struct

"""Файл — это последовательность байтов,хранящаяся в определенной файловой системе,
к которой можно получить доступ по имени файла. 
Каталог — это коллекция файлов и, возможно, других каталогов.
Слово «папка» является синонимом каталога
Самый простой вид хранения — это старый добрый файл, иногда называемый плоским файлом. 
Он представляет собой последовательность байтов, которая хранится под именем файла. 
Вы считываете данные из файла в память и записываете данные из памяти в файл."""

"""
Первая буква строки mode указывает на операцию:
- r означает чтение;
- w означает запись. Если файла не существует, он будет создан. 
    Если файл существует, он будет перезаписан;
- x означает запись, но только если файла еще не существует;
- a означает добавление данных в конец файла, если он существует.
Вторая буква строки mode указывает на тип файла:
- t (или ничего) означает, что файл текстовый;
- b означает, что файл бинарный.
"""
"""Записываем в текстовый файл с помощью функции print(). """
# fout = open('oops.txt', 'wt')
# print('Oops, I created a file.', file=fout)
# fout.close()
"""Записываем в текстовый файл с помощью функции write(). Функция write() возвращает число 
записанных байтов. Она не добавляет никаких пробелов или символов новой строки, в отличие 
от функции print. Для того чтобы функция print() работала как функция write(), передайте ей 
два следующих аргумента:  sep='', end=''"""
poem = '''There was a young lady named Bright,
    Whose speed was far faster than light;
    She started one day
    In a relative way,
    And returned on the previous night.'''
# fout = open('relativity', 'wt')
# fout.write(poem)
# fout.close()
"""Если исходная строка большая, вы можете записывать в файл ее фрагменты 
(используя разделения (слайсы)) до тех пор, пока не запишете всю:"""
# fout = open('relativity', 'wt')
# size = len(poem)    # 166
# offset = 0
# chunk = 100
# while True:
#     if offset > size:
#         break
#     fout.write(poem[offset:offset+chunk])
#     offset += chunk
# fout.close()
"""Этот код записал 100 символов первым заходом и оставшиеся 66 — вторым. Слайсы позволяют вам 
забраться за границы последовательности без генерации исключения."""
"""Если файл relativity нам очень дорог, проверим, спасет ли режим х его от перезаписывания.
Вы можете использовать этот код вместе с обработчиком исключений"""
# try:
#     fout = open('relativity', 'xt')
#     fout.write('stomp stomp stomp')
# except FileExistsError:
#     print('relativity already exists!. That was a close one.')
"""Считываем данные из текстового файла, используя функции read(), readline() и readlines()
Вы можете вызвать функцию read() без аргументов, чтобы достать весь файл сразу. 
Будьте осторожны, делая это с крупными файлами: файл размером 1 Гбайт потребит 1 Гбайт памят.
Вы можете указать максимальное количество символов, которое функция read() вернет за один вызов.
Мы будем считывать по 100 символов за раз и присоединять каждый фрагмент к строке poem_,
 чтобы восстановить оригинал"""
poem_2 = ''
fin = open('relativity', 'rt')
chunk = 100
while True:
    fragment = fin.read(chunk)
    if not fragment:
        break
    poem_2 += fragment
fin.close()
len(poem_2)     # 166
"""Вы также можете считывать файл построчно с помощью функции readline()."""
poem_3 = ''
fin = open('relativity', 'rt')
while True:
    line = fin.readline()
    if not line:
        break
    poem_3 += line
fin.close()
len(poem_3)    # 166
"""Для текстового файла даже пустая строка имеет длину, равную 1 (символ новой строки), такая 
строка будет считаться True. Когда весь файл будет считан, функция readline() 
(как и функция read()) возвратит пустую строку, которая будет считаться False"""
"""Самый простой способ считать текстовый файл — использовать итератор."""
poem_4 = ''
fin = open('relativity', 'rt')
for line in fin:
    poem_4 += line
fin.close()
len(poem_4)    # 166
"""Во всех предыдущих примерах в результате получалась одна строка poem. Функция readlines()
считывает по одной строке за раз и возвращает список этих строк:"""
fin = open('relativity', 'rt')
lines = fin.readlines()
fin.close()
f'{len(lines)}, lines read'  # 5 lines read
# for line in lines:
#     print(line, end='')
"""
There was a young lady named Bright,
    Whose speed was far faster than light;
    She started one day
    In a relative way,
    And returned on the previous night.
"""
"""Записываем данные в бинарный файл с помощью функции write()
Если вы включите символ 'b' в строку режима, файл откроется в бинарном режиме.
В этом случае вы будете читать и записывать байты, а не строки."""
bdata = bytes(range(0, 256))
len(bdata)  # 256
fout = open('bfile', 'wb')
fout.write(bdata)
fout.close()
"""Читаем бинарные файлы с помощью функции read(). Все, что вам нужно,
— открыть файл в режиме 'rb'"""
fin = open('bfile', 'rb')
bdata = fin.read()
len(bdata)  # 256
fin.close()
"""Закрываем файлы автоматически с помощью ключевого слова with"""
"""У Python имеются менеджеры контекста для очистки таких объектов, как открытые файлы.
Вы можете использовать конструкцию with выражение as переменная:"""
with open('relativity', 'wt') as fout:
    fout.write(poem)
"""После того как блок кода, расположенный под менеджером контекста (в данном случае 
это одна строка), завершится (или нормально, или путем генерации исключения), 
файл закроется автоматически."""
"""Меняем позицию с помощью функции seek()
В процессе чтения и записи Python отслеживает ваше местоположение в файле.
Функция tell() возвращает ваше текущее смещение от начала файла в байтах.
Функция seek() позволяет перейти к другому смещению в файле. Это значит, что
вам не обязательно прочитывать каждый байт файла, чтобы добраться до последнего, — 
вы можете использовать функцию seek(): сместиться именно к нужному байту и считать его."""
fin = open('bfile', 'rb')
fin.tell()      # 0
"""Используем функцию seek(), чтобы перейти к последнему байту файла"""
fin.seek(255)    # 255
"""Считаем все данные от текущей позиции до конца файла"""
bdata = fin.read()
len(bdata)      # 1
# bdata[0]        # 255
# fin = open('bfile', 'rb')
# bdata = fin.read()
# for elem in bdata:
#     print(bdata[elem], end=' ')
"""Функция seek() также возвращает текущее смещение. Вы также можете вызвать функцию seek(), 
передав ей второй аргумент seek(offset, origin):
- если значение origin равно 0 (по умолчанию), вы сместитесь на offset байтов
от начала файла;
- если значение origin равно 1, вы сместитесь на offset байтов с текущей позиции 
(если указать отрицательное смещение offset = -10 то смещение произойдет в обратную сторону);
- если значение origin равно 2, вы сместитесь на offset байтов от конца файла.
(если указать отрицательное смещение offset = -10 то смещение произойдет в обратную сторону);
"""
fin = open('bfile', 'rb')
# print(fin.seek(254, 0))                         # 254
# end_list = fin.read(fin.seek(254, 0))           # b'\xfe\xff'
# print(len(end_list), [el for el in end_list])   # 2 [254, 255]
# print(fin.seek(1, 1))                           # 255
# print(fin.seek(5, 2))                           # 261
bdata = fin.read()
fin.close()

"""Отображение в памяти
Альтернативой чтению и записи файла является его отображение в памяти (memory-map) с помощью
стандартного модуля mmap. Такой подход позволяет представить содержимое файла как bytearray 
в памяти. Для получения более подробной информации обратитесь к документации 
(https://docs.python.org/3.7/library/mmap.html) и примерам (https://pymotw.com/3/mmap/index.html).
"""

"""Операции с файлами
В Python, как и во многих других языках программирования, операции для работы с файлами основаны
 на аналогичных операциях ОС Unix. Некоторые функции, такие как chown() и chmod(), называются
одинаково, но теперь появились и новые названия."""

"""Проверяем существование файла с помощью функции exists()
Если хотите убедиться в том, что файл или каталог действительно существуют, а не являются 
плодом вашего воображения, воспользуйтесь функцией exists(). Передайте функции относительное 
или абсолютное имя файла"""
import os
# print(os.path.exists('oops.txt'))   # True
# print(os.path.exists('.\oops.txt')) # True
# print(os.path.exists('waffles'))    # False

"""Проверяем тип с помощью функции isfile()
Функции проверяют, ссылается ли имя на файл, каталог или символьную ссылку. Рассмотрим функцию
isfile(). Она задает простой вопрос: переднами находится старый добрый законопослушный файл?"""
# name = 'oops.txt'
# print(os.path.isfile(name))       # True
"""Вот так можно определить папку os.path.isdir(name_folder)"""
# print(os.path.isdir(name))        # False
"""Одна точка (.) является сокращением для текущей папки, а две точки 
(..) — для родительской. Эти папки существуют всегда"""

"""Модуль os содержит множество функций, работающих с pathname (именем пути) — полным именем файла,
начинающимся с символа / и включающим в себя имена всех вложенных файлов. Одна из таких функций,
isabs(), определяет, является ли аргумент абсолютным путем. Аргумент не обязательно
 должен быть именем реально существующего файла"""
# print(os.path.isabs(name))      # False
# print(os.path.isabs(r'E:\Projects\Core_Python\Ch_14_Files_and_Directories\name'))   # True

"""Копируем файлы, используя функцию copy(). Функция copy() находится в другом модуле, 
shutil. В этом примере файл oops.txt копируется в файл ohno.txt:"""
import shutil, stat
# shutil.copy('oops.txt', 'ohno.txt')
"""Функция shutil.move() копирует файл, а затем удаляет оригинал."""

"""Изменяем имена файлов с помощью функции rename()"""
# os.rename('ohno.txt', 'ohwell.txt')

"""Создаем ссылки с помощью функции link() или symlink()"""
"""В операционных системах семейства Unix файл находится в одном определенном месте, но может 
иметь несколько имен, называемых ссылками. В низкоуровневых жестких ссылках найти все имена 
заданного файла не так уж легко. Символьная ссылка — это альтернативный метод, который 
сохраняет новое имя в своем собственном файле, позволяя вам получить одновременно 
оба имени — оригинальное и новое.
Вызов link() создает жесткую ссылку,
symlink() — символьную ссылку. 
Функция islink() проверяет, является ли файл символьной ссылкой.
"""
# os.link('oops.txt', 'yikes.txt')
os.path.isfile('yikes.txt')          # True
os.path.islink('yikes.txt')          # False

"""Изменяем разрешения с помощью функции chmod() В системах Unix функция chmod() 
вносит изменения в права на доступ к файлу. Существуют права на чтение, запись и 
выполнение файла для пользователя (обычно того, кто создавал файл), а также для 
какой-то группы, в которой состоит пользователь, и для всех остальных. Команда 
принимает сильно сжатое восьмеричное значение (в системе счисления с основанием 8),
в котором указаны пользователь, группа и другие, кто имеет доступ. Например, для 
указания того, что файл oops.txt для чтения доступен только своему владельцу, 
нужно ввести следующий код"""
# os.chmod('oops.txt', 0o400)
"""Если вы не хотите работать с загадочными восьмеричными значениями и предпочитаете 
иметь дело с более понятными символами, можете импортировать некоторые константы из
модуля stat и использовать такое выражение:"""
# os.chmod('oops.txt', stat.S_IXUSR)

"""Изменение владельца файла с помощью функции chown() Эта функция также характерна 
для систем Unix/Linux/Mac. Вы можете изменить владельца и/или группу, указав числовой
 идентификатор пользователя ID (uid) и идентификатор группы (gid):"""

"""Удаляем файл с помощью функции remove() В этом фрагментемы используем функцию remove()
 и попрощаемся с файлом oops.txt:"""
# os.remove('oops.txt')

"""Каталоги. В большинстве операционных систем файлы существуют в рамках иерархии каталогов
(иначе их еще называют папками). Контейнером для всех этих файлов и каталогов служит
файловая система (иногда ее называют томом). Стандартный модуль os работает с такой
 иерархией и предоставляет функции, с помощью которых ею можно манипулировать."""
"""Создаем каталог с помощью функции mkdir()"""
# os.mkdir('poems')
os.path.exists('poems')      # True
# os.rmdir('poems')
os.path.exists('poems')      # False
"""Выводим на экран содержимое каталога с помощью функции listdir()"""
# os.mkdir('poems')
"""получим список всех файлов, содержащихся в этом каталоге (их пока нет)"""
os.listdir('poems')          # []
"""Далее создадим подкаталог"""
# os.mkdir('poems\mcinytre')
os.listdir('poems')          # ['mcinytre']
"""Создайте в подкаталоге файл"""
file = open(r'poems\mcinytre\the_good_man', 'wt')
file.write('''Cheerful and happy was his mood''')
file.close()
"""проверьте, что получилось. Хорошо, если бы файл там был"""
os.listdir('poems\mcinytre')    # ['the_good_man']
"""Изменяем текущий каталог с помощью функции chdir()"""
os.chdir('poems')
os.listdir()     # ['mcinytre']

"""Практически во всех компьютерах используется иерархическая файловая система, в которой каталоги
(папки) содержат файлы и другие каталоги произвольного уровня вложенности. Если вы хотите
обратиться к определенному файлу или каталогу, вам необходимо указать его путь (pathname):
 последовательность каталогов, необходимых для того, чтобы добраться до искомого объекта.
Последовательность может быть 
абсолютной и начинаться сверху (от корня),
относительной и начинаться с вашего текущего каталога."""

"""Python позволяет использовать слеш в качестве разделителя пути. Вы должны использовать 
необработанные строки Python:"""
win_file2 = r'eek\urk\snort.txt'
"""При создании pathname вы можете сделать следующее
- использовать подходящий символ разделителя пути ('/' или '\');
- построить путь
- использовать модуль pathlib
"""

"""Функция abspath() расширяет относительное имя до абсолютного."""
# print(os.path.abspath('oops.txt'))
# E:\Projects\Core_Python\Ch_14_Files_and_Directories\poems\oops.txt

"""Построение пути с помощью функции os.path.join()"""
win_file = os.path.join("eek", "urk", "snort.txt")
# print(win_file)  # eek\urk\snort.txt

"""В Python модуль pathlib представляет собой альтернативу модулям os.path. Вместо того чтобы 
считать пути строками, этот модуль создает объект типа Path, чтобы работать с ними на более 
высоком уровне. Создайте объект типа Path с помощью вызова Path(), а затем склейте все 
элементы вашего пути с помощью простых слешей (а не символов '/'):"""
from pathlib import Path
file_path = Path('eek') / 'urk' / 'snort.txt'
# print(file_path)        # eek\urk\snort.txt
# print(file_path.name)   # snort.txt
"""Вы можете передать переменную file_path в функцию open(), как и любое имя файла или строку пути
"""
# TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS
"""14.1. Выведите на экран список всех файлов из текущего каталога."""
# print(os.listdir('.'))      # ['mcinytre']
###################################################################################################
"""14.2. Выведите на экран список всех файлов из родительского каталога."""
# print(os.listdir('..'))
# ['bfile', 'Files_and_Directories.py', 'ohno.txt', 'ohwell.txt',
# 'oops.txt', 'poems', 'relativity', 'yikes.txt']
###################################################################################################
"""14.3. Присвойте строку This is a test of the emergency text system переменной test1
и запишите эту переменную в файл с именем test.txt."""
os.chdir('..')
test1 = "This is a test of the emergency text system"
with open('test.txt', 'wt') as file:
    file.write(test1)
###################################################################################################
"""14.4. Откройте файл test.txt и считайте его содержимое в строку test2. Будут ли
одинаковыми строки test1 и test2?
"""
with open('test.txt', 'rt') as file:
    test2 = file.read()
# print(test1 == test2)       # True
