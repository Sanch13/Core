import string, pickle

"""В 1989 году английский ученый Тим Бернерс-Ли впервые внес предложение помочь распространять
информацию внутри CERN, а также среди всего исследовательского сообщества. Он назвал
его World Wide Web (Всемирная паутина) и довольно быстро выделил три основные идеи, которые должны 
были лечь в основу ее дизайна:
- HTTP (Hypertext Transfer Protocol — протокол передачи гипертекста) — протокол для веб-клиентов и 
    серверов для обмена запросами и ответами;
- HTML (Hypertext Markup Language — гипертекстовый язык разметки) — формат для представления
    результатов;
- URL (Uniform Resource Locator — единообразный локатор ресурса) — способ уникально обозначить
    сервер и ресурс на этом сервере."""
"""В самом простом варианте использования веб-клиент соединяется с веб-сервером с помощью
протокола HTTP, запрашивает URL и получает HTML."""
"""Python особенно хорош для работы в Интернете на любом из таких уровней, как:
- клиенты для удаленного доступа;
- серверы, предоставляющие данные для сайтов и веб-API;
- веб-API и сервисы, позволяющие обмениваться данными другими способами, отличающимися от 
просматриваемых веб-страниц."""

"""Веб-клиенты
Низкоуровневая система проводящих путей Интернета называется 
Transmission Control Protocol/Internet Protocol (протокол управления передачей/интернетпротокол) 
или просто TCP/IP. Он перемещает байты между компьютерами, но не обращает внимания на то, что они
значат. Это работа высокоуровневых протоколов — определений синтаксиса для некоторых целей. 
HTTP — стандартный протокол для обмена данными в Сети. Всемирная паутина — это клиент-серверная
система. Клиент делает запрос серверу: он открывает соединение TCP/IP, отправляет URL и другую 
информацию с помощью HTTP и получает ответ. Формат ответа также определяется протоколом HTTP. 
Он включает в себя статус запроса и (в том случае, если запрос выполнен успешно) данные и формат
ответа. Самый известный веб-клиент — это браузер. Он может создавать HTTP-запросы несколькими 
способами. Вы можете инициировать запрос вручную, написав URL в адресной строке или нажав ссылку
на веб-странице. Очень часто для отображения сайта используются возвращаемые данные: 
HTML-документы, файлы JavaScript, файлы CSS и изображения, но данные могут быть любого типа, в том
числе и не предназначенные для отображения. Важный аспект HTTP — этот протокол не имеет состояния. 
Каждое создаваемое вами соединение HTTP не зависит от других. Это упрощает базовые операции, но
усложняет другие. Рассмотрим несколько примеров таких усложнений.
- Кэширование. Удаленный контент, который не меняется, должен быть сохранен веб-клиентом и 
    использован для того, чтобы не загружать его с сервера снова.
- Сессии. Интернет-магазин должен запоминать содержимое вашей корзины.
- Аутентификация. Сайты, которые требуют ваши имя пользователя и пароль, должны запоминать их, 
    пока вы авторизованы. 
Решения для описанных усложнений включают в себя cookie, в которых сервер
отправляет клиенту довольно специфическую информацию, позволяющую их распознать, когда клиент 
отправляет эти файлы назад."""

"""Стандартные веб-библиотеки Python
http управляет всеми деталями клиент-серверного взаимодействия HTTP:
- client выполняет всю работу на стороне клиента;
- server помогает написать веб-сервер Python;
- cookies и cookiejar управляют cookies, которые сохраняют данные между посещениями;
urllib работает на базе http:
- request обрабатывает клиентские запросы;
- response обрабатывает ответы сервера;
- parse разбивает URL на части.
"""
"""Воспользуемся стандартной библиотекой с целью получить что-либо с сайта."""
import urllib.request as ur
url = 'http://www.example.com/'
conn = ur.urlopen(url)
# print(conn)  # <http.client.HTTPResponse object at 0x0000017F1E355DF0>
# with open('example_com.txt', 'wt', encoding='utf-8') as file:
#     for el in conn:
#         file.write(el.decode("utf-8"))    # check example_com
# print(conn.status)  # 200. Значение 200 означает, что все прошло гладко.
"""Существуют десятки кодов статуса HTTP, объединенных в пять диапазонов в соответствии с их
первой цифрой (сотни):
- 1xx (информация) — сервер получил запрос, но имеет некую дополнительную информацию для клиента;
- 2xx (успех) — сработало, каждый код успеха, кроме 200, сообщает дополнительные детали;
- 3xx (перенаправление) — ресурс был перемещен, поэтому ответ возвращает клиенту новый URL;
- 4xx (ошибка клиента) — некие проблемы на стороне клиента, например знаменитая ошибка 404 
    (ресурс не найден). Код 418 (I’m a teapot) был первоапрельской шуткой;
- 5xx (ошибка сервера) — код 500 — общая ошибка. Вы можете встретить ошибку 502 (ошибочный шлюз), 
    если произошел разрыв связи между веб-сервером и машинным интерфейсом."""
"""Для большинства задач, связанных с разработкой веб-клиентов, 
проще использовать библиотеку requests."""
import requests
resp = requests.get(url)
# print(resp)               # <Response [200]>
# print(resp.text[0:100])

"""Веб-серверы
Веб-разработчики обнаружили, что Python хорошо подходит для написания веб-серверов и программ, 
работающих на серверной стороне. Это привело к появлению такого множества фреймворков. 
Веб-фреймворк предоставляет функции, позволяющие построить сайты, поэтому может решать большее
количество задач, чем простой веб-сервер (HTTP)."""

"""Простейший веб-сервер Python
Вы можете запустить простейший веб-сервер, просто введя одну строку кода Python:
$ python -m http.server
С помощью этой строки вы реализуете примитивный Python HTTP-сервер.
Если не возникло никаких проблем, то вы увидите исходное сообщение о статусе:
Serving HTTP on 0.0.0.0 port 8000 ...
Теперь вы можете запрашивать файлы, чьи пути относительны к вашему текущему каталогу, и они будут 
вам возвращены. Если вы введете в своем браузере строку http://localhost:8000, 
то должны увидеть список каталогов и сервер выведет на экран строки обращения к журналам, 
например такие:
127.0.0.1 - - [10/Oct/2022 09:40:29] "GET / HTTP/1.1" 200 -
127.0.0.1 - - [10/Oct/2022 09:40:38] "GET /Ch_17_Data_in_Space_Networks/ HTTP/1.1" 200 -
127.0.0.1 - - [10/Oct/2022 09:43:02] "GET / HTTP/1.1" 200 -
127.0.0.1 - - [10/Oct/2022 09:43:06] "GET /Ch_10_Objects_and_Classes/ HTTP/1.1" 200 -
127.0.0.1 - - [10/Oct/2022 09:43:19] "GET /Ch_2_Data_Types/ HTTP/1.1" 200 -
127.0.0.1 - - [10/Oct/2022 09:43:21] "GET /Ch_2_Data_Types/Python_types.py HTTP/1.1" 200 -
"""
"""Элементы localhost и 127.0.0.1 являются для TCP синонимами вашего локального компьютера, поэтому
сработают независимо от того, подключены ли вы к Интернету. 
Вы можете интерпретировать эти строки следующим образом:
- 127.0.0.1 — IP-адрес клиента;
- первый символ - — имя удаленного пользователя, если он присутствует;
- второй символ - — имя авторизующегося пользователя, если требуется;
- [10/Oct/2022 09:40:29] — дата и время доступа;
- "GET/HTTP/1.1" — команда, отправленная веб-серверу:
    - метод HTTP (GET);
    - запрошенный ресурс (/, верхний уровень);
    - версия HTTP (HTTP/1.1);
- последнее число (200) — код статуса HTTP, возвращенный веб-сервером."""
"""Щелкните на любом файле. и сервер занесет этот запрос в журнал.
По умолчанию используется порт 8000, но вы можете указать любой другой.
Этот сервер, написанный только на Python, лучше всего подходит для быстрых тестов. Вы можете 
выключить его, убив его процесс нажатием Ctrl+C.
"""
"""Традиционные веб-серверы, такие как Apache и NGINX, гораздо быстрее работают со статическими
файлами. Кроме того, этот простой сервер не может взаимодействовать с динамическим содержимым, 
в отличие от более продвинутых серверов, принимающих дополнительные параметры."""

"""Web Server Gateway Interface (WSGI)
Довольно быстро необходимость в простых файлах исчезает, и нам уже нужен сервер, который может 
запускать программы динамически. В первые годы существования Всемирной паутины общий интерфейс 
шлюза (Common Gateway Interface, CGI) был разработан для того, чтобы веб-серверы могли запускать 
внешние программы и возвращать результаты. CGI также обрабатывал получение входных аргументов
от клиента, передавая их через сервер сторонним программам. Однако программы запускались заново 
при каждом обращении клиента. Масштабировать такие системы было трудно, поскольку даже у небольших
программ время загрузки довольно велико. Чтобы избежать задержки запуска, люди начали встраивать 
интерпретатор языка в веб-сервер. Apache запускал код на PHP внутри своего модуля mod_php,
Perl — внутри модуля mod_perl и Python — внутри модуля mod_python. Далее код этих динамических 
языков мог быть выполнен внутри долгоиграющего процесса Apache, а не во внешних программах.
Альтернативный метод заключается в том, чтобы запускать динамический язык внутри отдельной 
долгоиграющей программы и заставить ее обмениваться данными с веб-сервером. Примерами таких 
программ являются FastCGI и SCGI. Веб-разработка на Python совершила рывок с появлением Web 
Server Gateway Interface (WSGI) — универсального API между веб-приложениями и веб-серверами.
Все веб-фреймворки и веб-серверы Python, показанные далее, используют WSGI. Обычно вам не нужно 
знать, как функционирует данный интерфейс (для этого многого и не потребуется), но знание 
основных принципов его функционирования может действительно помочь разработке. Такое соединение 
называется синхронным — за одним шагом следует другой.
"""
"""apache
Лучшим WSGI-модулем apache (http://httpd.apache.org/) является mod_wsgi 
(https://code.google.com/p/modwsgi). Он может запускать код, написанный на Python, внутри процесса
Apache или в отдельном процессе, который обменивается данными с Apache. Если вы используете Linux 
или OS X, в вашей системе apache уже установлен. Для Windows вам придется устанавливать его 
самостоятельно (http://bit.ly/apache-http).
Наконец, установите предпочитаемый веб-фреймворк Python, основанный на WSGI. Попробуем использовать
в наших примерах фреймворк bottle. Практически вся работа включает в себя конфигурирование 
Apache, что может оказаться довольно затруднительным"""

"""NGINX
Веб-сервер NGINX (http://nginx.org/) не имеет встроенного модуля Python. Вместо этого он 
обменивается данными с помощью отдельного сервера WSGI, такого как uWSGI или gUnicorn. Вместе 
они представляют собой очень быструю и удобную в конфигурации платформу для веб-разработки на 
Python. Вы можете установить nginx с его официального сайта http://wiki.nginx.org/Install.
Небольшая страница документации (https://oreil.ly/7FTPa) предоставляет инструкции, позволяющие 
объединить Flask, NGINX и uWSGI."""

"""Другие веб-серверы Python
Ниже перечислены некоторые независимые WSGI-серверы, написанные на Python, которые работают как 
apache или nginx и используют несколько процессов и/или потоков  для обработки одновременных 
запросов:
- uwsgi (http://projects.unbit.it/uwsgi);
- cherrypy (http://www.cherrypy.org/);
- pylons (http://www.pylonsproject.org/).
А это серверы, основанные на событиях, которые пользуются одним процессом, но избегают 
блокирования любым одиночным запросом:
- tornado (http://www.tornadoweb.org/);
- gevent (http://gevent.org/);
- gunicorn (http://gunicorn.org/)."""

"""Фреймворки для работы веб-серверами
Веб-серверы обрабатывают детали работы HTTP и WSGI, но вам нужно использовать веб-фреймворки, 
чтобы написать код на Python, который будет поддерживать сайт. Написать сайт на Python можно с
помощью множества веб-фреймворков . Веб-фреймворк обрабатывает как минимум запросы клиента и
ответы сервера. Большинство крупных веб-фреймворков могут решать такие задачи, как:
- обработка протокола HTTP;
- аутентификация (authn, или «кто ты?»);
- авторизация (authz, или «что ты можешь сделать?»);
- создание сессии;
- получение параметров;
- валидация параметров (обязательные/опциональные, тип, диапазон);
- обработка глаголов HTTP;
- маршрутизация (функции/классы);
- выдача статических файлов (HTML, JS, CSS, изображения);
- динамических данных (базы данных, сервисы);
- возврат значений и статусов HTTP.
Опциональные возможности:
- создание шаблонов для бэкенда;
- соединение с базами данных, ORM;
- ограничение скорости;
- асинхронные задачи.
"""

"""Bottle
Bottle состоит из одного файла Python, поэтому его довольно легко опробовать и развернуть. Bottle 
не является частью стандартной библиотеки Python, поэтому установите его с помощью следующей 
команды:
$ pip install bottle

check --> bottle1.py
Bottle использует декоратор route, чтобы связать URL со следующей функцией; в этом примере / (
главная страница) обрабатывается функцией home(). Запустите данный сценарий сервера.
Обратившись по адресу http://localhost:9999, вы должны увидеть следующее:
It isn't fancy, but it's my home page
Функция run() запускает встроенный тестовый веб-сервер bottle. Вам не нужно использовать его в 
программах, написанных с помощью bottle, но это может оказаться полезным на первых порах 
разработки и тестирования.

check --> bottle2.py and index.html
В вызове static_file() мы хотим получить файл index.html из каталога, указанного в root 
(в нашем случае в '.', текущем каталоге). Если код предыдущего примера все еще выполняется, 
то остановите его. Каждый раз, когда вы обращаетесь к странице http:/localhost:9999/, вы должны
видеть следующее: My new and improved home page!!!

check --> bottle3.py and index.html
пример, который демонстрирует, как передавать аргументы в URL и использовать их. У нас появилась 
новая функция echo(), в которую мы хотим передавать строковый аргумент через URL. За это отвечает
строка @route('/echo/<thing>') в предыдущем примере. Конструкция <thing> в маршруте означает: 
все, что находится в URL после /echo/, присваивается строковому аргументу thing, который 
передается функции echo. Далее перейдите в браузере по ссылке http://localhost:9999/echo/Mothra.
Вы должны увидеть следующее: Say hello to my little friend: Mothra!
Оставьте bottle3.py работать еще на пару минут, чтобы мы могли попробовать что-либо еще. Вы 
проверяли работу этих примеров, вводя URL в браузер и глядя на отображаемые страницы. Вы также 
можете использовать клиентские библиотеки, такие как requests, чтобы они выполняли работу за вас.

check --> bottle_test.py
Теперь запустите bottle_test.py. В терминале вы должны увидеть следующее: 
It worked! That almost never happens!
Перед вами небольшой пример юнит-теста.

У фреймворка Bottle больше возможностей, чем я вам показал. В частности, при вызове функции run()
можно попробовать добавить следующие аргументы:
- debug=True — создает страницу отладки, если вы получаете ошибку HTTP;
- reloader=True — перезагружает страницу в браузере, если вы измените хотя бы небольшой кусочек 
кода.
Все это хорошо задокументировано на сайте разработчика http://bottlepy.org/docs/dev
"""
from flask import Flask, render_template, request
"""Flask
Bottle — это хороший фреймворк для того, чтобы начать работу. Но если вам нужно больше 
возможностей, то попробуйте Flask. Он был создан в 2010 годую. Flask почти так же прост в 
использовании, как и Bottle, но поддерживает множество расширений, которые могут оказаться 
полезными в профессиональной веб-разработке, например аутентификацию с помощью Facebook 
и интеграцию с базами данных. Это решение мне нравится больше других веб-фреймворков Python,
поскольку в нем сбалансированы простота применения и богатый набор функций. Пакет flask включает 
в себя библиотеку WSGI werkzeug и библиотеку шаблонов jinja2. Вы можете установить его с помощью 
терминала:
$ pip install flask
Переделаем наш последний пример с использованием фреймворка Flask. Однако для начала нужно внести
несколько изменений.
- Во Flask каталог по умолчанию для статических файлов называется static, и URL для таких файлов
тоже начинается со /static. Мы изменяем папку на '.' (текущий каталог) и префикс URL на ' ' (
пустой), чтобы позволить URL / отображать файл index.html.
- В функции run() установка параметра debug=True активизирует также автоматическую перезагрузку,
тогда как фреймворк bottle для отладки и перезагрузки использует отдельные аргументы.

check --> flask1.py
Протестируйте главную страницу, введя в браузер следующий URL:
http://localhost:9999/
Вы должны увидеть следующее (как и в случае с bottle): My new and improved home page!!!
Попробуйте обратиться к конечной точке /echo:
http://localhost:9999/echo/Godzilla
Вы должны увидеть следующее: Say hello to my little friend: Godzilla
Есть еще одно преимущество установки параметра debug равным True при вызове метода run. Если в
серверном коде генерируется исключение, то Flask возвращает особую отформатированную страницу,
содержащую полезные сведения о том, что и где пошло не так. Даже больше: вы можете вводить команды
с целью увидеть значения переменных в программе сервера. Не устанавливайте параметр debug = True
на производственных веб-серверах. Таким образом потенциальные злоумышленники получат слишком много
информации о вашем сервере.
До сих пор примеры с использованием Flask повторяли то, что мы делали с помощью фреймворка Bottle.
Что такого может делать Flask в отличие от Bottle? Flask содержит jinja2 — более широкую систему
шаблонов. Рассмотрим небольшой пример одновременного применения jinja2 и Flask.

Создайте каталог templates и файл flask2.html внутри него.
check --> flask2.py
Cерверный код, который получает этот шаблон, заполняет значение аргумента thing, передаваемого 
нами, и отрисовывает его как HTML. Аргумент thing = thing утверждает, что для передачи переменной 
с именем thing в шаблон эта переменная содержит значение строки thing.
Второй аргумент в URL, echo, вы можете передать множеством способов. Передача аргумента как части 
пути URL. С помощью этого метода вы просто расширяете URL.
"""
# @app.route('/echo/<thing>/<place>')
# def echo(thing, place):
#     return render_template('flask3.html', thing=thing, place=place)
"""URL должен выглядеть так:"""
# http://localhost:9999/echo/Rodan/McKeesport
"""Вы должны увидеть следующее:"""
# Say hello to my little friend: Rodan. Alas, it just destroyed McKeesport!
"""Или же вы можете передать аргументы как параметры команды GET"""
# @app.route('/echo/')
# def echo():
#     thing = request.args.get('thing')
#     place = request.args.get('place')
#     return render_template('flask3.html', thing=thing, place=place)
"""В этот раз используйте такой URL:"""
# http://localhost:9999/echo?thing=Gorgo&place=Wilmerding
"""Вы должны увидеть следующее:"""
# Say hello to my little friend: Gorgo. Alas, it just destroyed Wilmerding!
"""Когда команда GET используется в URL, любые аргументы должны передаваться в формате
&ключ1=знач1&ключ2=знач2&...
Вы также можете использовать оператор словаря **, чтобы передать несколько аргументов в шаблон 
с помощью одного словаря"""
# @app.route('/echo/')
# def echo():
#     kwargs = {}
#     kwargs['thing'] = request.args.get('thing')
#     kwargs['place'] = request.args.get('place')
#     return render_template('flask3.html', **kwargs)
"""Элемент **kwargs действует как конструкция thing=thing, place=place. Используя этот словарь,
можно сэкономить немного времени, если входных аргументов много.
У языка шаблонов jinja2 гораздо больше возможностей."""




