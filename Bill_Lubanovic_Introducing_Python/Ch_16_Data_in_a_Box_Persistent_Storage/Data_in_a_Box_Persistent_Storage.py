import random, unicodedata, os

"""Активная программа работает с данными, которые хранятся в запоминающем
устройстве с произвольным доступом (Random Access Memory, RAM). RAM — очень
быстрая память, но дорогая и требующая постоянного питания: если питание пропадет, то все данные,
 которые в ней хранятся, будут утеряны. Жесткие диски медленнее оперативной памяти.
"""

""" Плоские текстовые файлы
Самый простой пример постоянного хранилища — это старый добрый файл, который иногда называют
 еще плоским файлом. Он хорошо работает в том случае, когда у данных очень простая структура
и вы полностью записываете их на диск или считываете с него. Такой подход годится
 для простых текстовых данных.
"""

"""Текстовые файлы, дополненные пробелами В этом формате каждое поле записи имеет фиксированную
длину и при необходимости дополняется до требуемой длины (как правило, пробелами) так, чтобы
все записи имели одинаковый размер. Программист может использовать функцию seek() для перемещения
по файлу, для записи или только для чтения необходимых записей и полей. Для простых текстовых
файлов единственным уровнем организации является строка. Но иногда вам может понадобиться более
структурированный файл, чтобы сохранить данные из программы для дальнейшего использования
или отправить их другой программе.
Существует множество форматов, и у каждого есть свои особенности.
- CSV — формат со значениями, разделенными запятой. Разделитель (separator или delimiter) — такие
символы, как табуляция ('\t'), запятая (',') и др.
- XML и HTML. Символы '<' и '>' в окружении тегов.
- JSON. Знаки препинания. Примером является JavaScript Object Notation
- YAML — не язык разметки. аббревиатура расшифровывается как YAML Ain’t Markup Language.
- Другие файлы, например конфигурационные.
"""

"""CSV
Файлы с разделителями часто используются в качестве формата обмена данными
для электронных таблиц и баз данных. лучшим решением будет использовать стандартный модуль csv
 """
import csv

villains = [
    ['Doctor', 'No'],
    ['Rosa', 'Klebb'],
    ['Mister', 'Big'],
    ['Auric', 'Goldfinger'],
    ['Ernst', 'Blofeld'],
]
with open('villains.csv', 'wt') as file:  # менеджер контекста
    csvout = csv.writer(file)
    csvout.writerows(villains)
"""Этот код создает пять записей. попробуем считать их обратно"""
with open('villains.csv', 'rt') as fin:  # менеджер контекста
    cin = csv.reader(fin)
    vill = [row for row in cin]
# [['Doctor', 'No'], [], ['Rosa', 'Klebb'], [], ['Mister', 'Big'], [],
# ['Auric', 'Goldfinger'], [], ['Ernst', 'Blofeld'], []]
"""Используя функции reader() и writer() с их стандартными опциями, мы получим
столбцы, разделенные запятыми, и ряды, разделенные символами перевода строки. Данные могут иметь
формат списка словарей (DictReader(), DictWriter()) указывая имена столбцов, а не списка списков.
"""
# csv_in = csv.DictReader(file, fieldnames=['first', 'last'])
# csv_out = csv.DictWriter(file, ['first', 'last'])

"""XML
Файлы с разделителями отображают только два измерения: ряды (строки) и столбцы (поля внутри строк).
Если вы хотите обмениваться структурами данных между программами, вам нужен способ кодирования
иерархий, последовательностей, множеств и других структур в виде текста. XML является самым
известным форматом разметки, который можно применять в этом случае. Для разделения данных
он использует теги
"""
# <?xml version="1.0"?>
# <menu>
#     <breakfast hours="7-11">
#         <item price="$6.00">breakfast burritos</item>
#         <item price="$4.00">pancakes</item>
#     </breakfast>
#     <lunch hours="11-3">
#         <item price="$5.00">hamburger</item>
#     </lunch>
#     <dinner hours="3-10">
#         <item price="8.00">spaghetti</item>
#     </dinner>
# </menu>
"""Рассмотрим основные характеристики формата XML.
- Теги начинаются с символа <. В этом примере использованы теги menu, breakfast, lunch и item.
- Пробелы игнорируются.
- Обычно контент размещается после начального тега, такого как <menu>. Имеется и соответствующий
конечный тег, такой как </menu>.
- Теги могут быть вложены в другие теги на любой глубине.
- Внутри начального тега могут встретиться опциональные атрибуты. 
price является опциональным атрибутом тега item
- Теги могут содержать значения. первый тег item имеет значение burritos
- Если у тега с именем thing нет значений или потомков, он может быть оформлен (<thing/>)
- Место размещения данных — атрибутов, значений или тегов-потомков — является в какой-то мере
произвольным. Например, мы могли бы написать последний тег 
item как <item price="$8.00" food="spaghetti"/>"""
"""XML часто используется в каналах данных и сообщениях, у него есть такие подформаты, как 
RSS и Atom. Библиотека ElementTree имеет множество других способов поиска данных, организованных
в формате XML, модификации этих данных и даже записи XML-файлов. Все детали изложены в 
документации библиотеки ElementTree (http://bit.ly/elementtree).
Среди других библиотек Python для работы с XML можно отметить следующие:
- xml.dom. The Document Object Model (DOM) (знакомая разработчикам на JavaScript) представляет
веб-документы в виде иерархических структур. Этот модуль загружает XML-файл в память целиком и 
позволяет получать доступ ко всем его частям;
- xml.sax. Simple API for XML, или SAX, разбирает XML на ходу, поэтому не загружает в память
сразу весь документ. Она может быть хорошим выбором, если нужно обработать очень большие потоки XML
"""

"""HTML
Огромные объемы данных сохраняются в формате гипертекстового языка разметки 
— Hypertext Markup Language (HTML). 
Это основной формат документов в Интернете. Проблема заключается в том, что значительная часть
этих документов не соответствует правилам формата HTML, что затрудняет анализ."""

"""JSON
- JavaScript Object Notation (JSON) (http://www.json.org/) стал очень популярным форматом обмена
данными, вышедшим за пределы языка JavaScript. Он прекрасно подходит Python, что делает его 
хорошим выбором для обмена данными между программами. В отличие от XML, для которого написано
 множество модулей, для JSON существует всего один модуль с простым именем json. """
import json
menu = \
    {
        "breakfast": {
            "hours": "7-11",
            "items": {
                "breakfast burritos": "$6.00",
                "pancakes": "$4.00"
            }
        },
        "lunch": {
            "hours": "11-3",
            "items": {
                "hamburger": "$5.00"
            }
        },
        "dinner": {
            "hours": "3-10",
            "items": {
                "spaghetti": "$8.00"
            }
        }
    }

"""закодируем структуру данных menu в строку JSON menu_json с помощью функции dumps()"""
menu_json = json.dumps(menu)
# {"breakfast": {"hours": "7-11", "items": {"breakfast burritos": "$6.00", "pancakes": "$4.00"}},
# "lunch": {"hours": "11-3", "items": {"hamburger": "$5.00"}},
# "dinner": {"hours": "3-10", "items": {"spaghetti": "$8.00"}}}
"""А теперь превратим строку JSON menu_json обратно в структуру данных
 menu2 с помощью функции loads()"""
menu2 = json.loads(menu_json)
# {'breakfast': {'hours': '7-11', 'items': {'breakfast burritos': '$6.00', 'pancakes': '$4.00'}},
# 'lunch': {'hours': '11-3', 'items': {'hamburger': '$5.00'}},
# 'dinner': {'hours': '3-10', 'items': {'spaghetti': '$8.00'}}}
"""menu и menu2 являются словарями с одинаковыми ключами и значениями."""
"""Вы можете получить исключение, пытаясь закодировать или декодировать некоторые объекты,
например datetime. Это может случиться, поскольку стандарт JSON не определяет типы даты или
времени — он ожидает, что вы укажете ему, как с ними работать. Вы можете преобразовать формат
datetime в то, что JSON понимает, например в строку или значение времени epoch"""
"""При работе с JSON и другими форматами структурированного текста вы можете загрузить файл в 
память и разместить его в структуре данных, не зная о самих структурах заранее. Затем вы можете
пройтись по структурам, используя функцию isinstance() и методы, соответствующие типу, чтобы
проверить значения структур. Например, если один из элементов является словарем, вы можете 
извлечь его содержимое с помощью функций keys(), values() и items()."""
"""существует более простой способ преобразовать объекты типа datetime в JSON"""
import datetime
now = datetime.datetime.now()
data_json = json.dumps(now, default=str)
# data_json  # "2022-09-29 10:44:30.357021"
"""Инструкция default=str указывает функции json.dumps() применить функцию преобразования str()
к тем типам данных, которые она не понимает. Это сработает, поскольку в определении класса
datetime.datetime присутствует метод __str__()."""

"""YAML
Как и JSON, YAML (http://www.yaml.org/) имеет ключи и значения, но обрабатывает большее 
количество типов данных, включая дату и время. Стандартная библиотека Python не содержит 
модулей, работающих с YAML, поэтому вам нужно установить стороннюю библиотеку yaml 
(http://pyyaml.org/wiki/PyYAML). Функция load() преобразует строку в формате YAML к данным Python,
а функция dump() предназначена для противоположного действия."""
"""Такие значения, как true, false, on и off, преобразуются в булевы переменные. Целые числа и
строки преобразуются в их эквиваленты в Python. Для остального синтаксиса 
создаются списки и словари:"""
import yaml
with open('mcintyre.yaml', 'rt') as file:
    text = file.read()
data = yaml.full_load(text)
# data -->  {'name': None, 'first': 'James', 'last': 'McIntyre', 'dates': None, 'birth': datetime.date(1828, 5, 25), 'death': datetime.date(1906, 3, 31), 'details': None, 'bearded': True, 'themes': ['cheese', 'Canada'], 'books': None, 'url': 'http://www.gutenberg.org/files/36068/36068-h/36068-h.htm', 'poems': [{'title': 'Motto', 'text': 'Politeness, perseverance and pluck,\nTo their possessor will bring good luck.\n'}, {'title': 'Canadian Charms', 'text': 'Here industry is not in vain,\nFor we have bounteous crops of grain,\nAnd you behold on every field\nOf grass and roots abundant yield,\nBut after all the greatest charm\nIs the snug home upon the farm,\nAnd stone walls now keep cattle warm.'}]}
# data['poems']) -->    [{'title': 'Motto', 'text': 'Politeness, perseverance and pluck,\nTo their possessor will bring good luck.\n'}, {'title': 'Canadian Charms', 'text': 'Here industry is not in vain,\nFor we have bounteous crops of grain,\nAnd you behold on every field\nOf grass and roots abundant yield,\nBut after all the greatest charm\nIs the snug home upon the farm,\nAnd stone walls now keep cattle warm.'}]
# data['poems'][1]['title'] -->  Canadian Charms
"""PyYAML может загружать объекты Python из строк, а это опасно. Используйте метод safe_load() 
вместо метода load(), если импортируете данные в формате YAML, которым не доверяете. А лучше 
всегда используйте метод safe_load(). Прочтите статью Неда Батчелдера War is peace 
(http://nedbatchelder.com/blog/201302/war_is_peace.html), чтобы узнать о том, как незащищенная
загрузка YAML скомпрометировала платформу Ruby on Rails."""

"""Tablib
Существует сторонний пакет, который позволяет импортировать, экспортировать и изменять табличные
данные в форматах CSV, JSON или YAML1, а также данные в MicrosoftExcel, Pandas DataFrame
и некоторые другие. Вы можете установить его привычным способом (pip install tablib), а также 
заглянуть в документацию (http://docs.python-tablib.org/en/master/)."""

"""Pandas
Сейчас самое время познакомиться с Pandas (https://pandas.pydata.org/) — библиотекой Python для
структурированных данных. Это отличный инструмент для решения реальных проблем с данными. Она 
позволяет:
- читать и записывать данные во множестве текстовых и бинарных форматов, таких как:
    -> текст, поля которого разделены запятыми (CSV), символами табуляции (TSV) или др. символами;
    -> текст фиксированной длины;
    -> Excel;
    -> JSON;
    -> таблицы HTML;
    -> SQL;
    -> HDF5;
    -> и др. (https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html);
- группировать, разбивать, объединять, разделять, сортировать, выбирать и помечать;
- преобразовывать типы данных;
- изменять размер или форму;
- обрабатывать случаи, когда данные отсутствуют;
- генерировать случайные значения;
- управлять временными последовательностями."""
"""Функции чтения возвращают объект типа DataFrame 
(https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html). 
Это является стандартным представлением для двумерных данных (которые делятся на строки и столбцы)
в Pandas. Объект этого типа похож на электронную таблицу или таблицу реляционной базы данных. 
Его одномерный младший брат называется Series 
(https://pandas.pydata.org/pandas-docs/stable/reference/series.html)."""
import pandas
data_pand = pandas.read_csv('villains.csv')
# print(data_pand)
#    Doctor          No
# 0    Rosa       Klebb
# 1  Mister         Big
# 2   Auric  Goldfinger
# 3   Ernst     Blofeld
"""Переменная data имеет тип DataFrame: у этого типа данных возможностей больше, чем у простого
словаря Python. Он особенно полезен для обработки большого количества чисел с помощью NumPy, а
также для подготовки данных для машинного обучения."""
"""Обратитесь к разделам Getting Started 
(https://pandas.pydata.org/pandas-docs/stable/getting_started/index.html) документации Pandas,
чтобы узнать подробнее о ее особенностях, и к разделу 10 Minutes to Pandas 
(https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html) 
для того, чтобы увидеть рабочие примеры."""
"""Создадим небольшой календарь — список, содержащий первый день первых трех месяцев 2023 года"""
dates = pandas.date_range('2023-01-01', periods=3, freq='MS')
# dates DatetimeIndex(['2023-01-01', '2023-02-01', '2023-03-01'], dtype='datetime64[ns]', freq='MS')
"""Pandas также позволяет обрабатывать множество особых деталей даты и времени 
(https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html), 
например бизнес-месяцы и годы."""

"""Конфигурационные файлы
Большинство программ предлагают различные параметры или настройки. Динамические настройки 
могут быть переданы как аргументы программы, но долговременные настройки должны где-то храниться.
Как правило, это бывает и неточно, и не так уж быстро. Вам нужно обслуживать как 
программу-писатель, так и программу-читатель (которая иногда называется парсером). 
Существуют хорошие альтернативы, которые вы можете добавить в свою программу, включая те,
что были показаны в предыдущих подразделах. Здесь мы используем стандартный модуль configparser,
который обрабатывает файлы с расширением .ini, характерные для Windows. Такие файлы имеют разделы
с определениями ключ = значение. Так выглядит минимальный файл settings.cfg"""
import configparser
cfg = configparser.ConfigParser()
cfg.read('settings.cfg')
# print(*cfg.items())
#  ('DEFAULT', <Section: DEFAULT>) ('english', <Section: english>) ('files', <Section: files>)
"""Доступны и другие опции, в том числе более мощная интерполяция. Обратитесь к документации 
configparser (http://bit.ly/configparser)."""

"""Бинарные файлы
Некоторые файловые форматы были разработаны для хранения определенных структур данных и не 
являются ни реляционными базами данных, ни базами данных NoSQL. Заполненные пробелами бинарные
файлы и управление памятью. Такие файлы похожи на заполненные пробелами текстовые файлы, 
но содержимое может быть бинарным, а в качестве заполнителя может использоваться байт \x00. 
Каждая запись имеет фиксированный размер, как и каждое поле внутри записи. Это позволяет
легче искать нужные записи и поля с помощью функции seek(). Каждая операция с данными 
выполняется вручную, поэтому такой подход должен применяться только в очень низкоуровневых
(близких к «железу») ситуациях. Данные в таком формате могут быть размещены в ОЗУ с помощью
стандартной библиотеки mmap. Взгляните на примеры (https://pymotw.com/3/mmap/) и стандартную
документацию (https://docs.python.org/3.7/library/mmap.html)."""

"""Электронные таблицы
Электронные таблицы, в частности Microsoft Excel, — это широко распространенный бинарный формат
данных. Если вы можете сохранить свою таблицу в CSV-файл, то можете считать его с помощью
 стандартного модуля csv, который был описан ранее. Это распространяется на бинарный файл xls:
для его считывания и записи можно использовать стороннюю библиотеку
xlrd (https://pypi.org/project/xlrd/) или tablib"""

"""HDF5
HDF5 (http://www.hdfgroup.org/why_hdf) — это бинарный формат данных, предназначенный для хранения
многомерных или иерархических числовых данных. Обычно он используется в научных целях, 
где быстрый случайный доступ к крупным наборам данных (от гигабайтов до терабайтов) является
распространенным требованием. Несмотря на то что HDF5 в некоторых случаях мог бы стать хорошей
альтернативой базам данных, по каким-то причинам этот формат практически неизвестен в
современном мире. Он лучше всего подходит для приложений вида WORM 
(write once — read many — «запиши однажды — считай много раз»), которые не нуждаются в защите от
конфликтующих записей. Вам могут быть полезными следующие модули:
- h5py — интерфейс низкого уровня с широкими возможностями. Прочтите его документацию 
(http://www.h5py.org/) и код (https://github.com/h5py/h5py);
- PyTables — интерфейс немного более высокого уровня, имеющий некоторые особенности, 
характерные для баз данных. Прочтите его документацию 
(http://www.pytables.org/) и код (http://pytables.github.com/)."""

"""TileDB
У формата HDF5 недавно появился последователь, который позволяет хранить как плотные, так и
разреженные массивы — TileDB (https://tiledb.com/). 
Установитеинтерфейс Python (https://github.com/TileDB-Inc/TileDB-Py) 
(он включает в себя и самубиблиотеку TileDB), запустив команду pip install tiledb. 
Эта библиотека предназначена для работы с научными данными и приложениями."""

