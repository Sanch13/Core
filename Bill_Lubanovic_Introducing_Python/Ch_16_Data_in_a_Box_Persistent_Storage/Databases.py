import string

"""Реляционные базы данных
Реляционным базам данных всего около 40 лет, но в компьютерном мире они используются повсеместно.
Преимущества:
- Доступ к данным возможен для нескольких пользователей одновременно.
- Действует защита от повреждения данных пользователями.
- Существуют эффективные методы сохранения и считывания данных.
- Данные определены схемами и имеют ограничения.
- Объединения позволяют найти отношения между различными типами данных.
- Декларативный (в противоположность императивному) язык запросов SQL (Structured Query Language).
"""
"""Такие базы данных называются реляционными, поскольку они показывают отношения между различными
типами данных в форме прямоугольных таблиц."""
"""Таблица представляет собой прямоугольную сетку столбцов (полей данных) и строк 
(отдельных записей), похожую на электронную таблицу. Пересечение строки и столбца называется
ячейкой. Чтобы создать таблицу, необходимо указать ее имя и порядок, имена и типы ее столбцов.
Каждая строка имеет одинаковые столбцы, хотя столбец может быть определен так, чтобы в ячейках
отсутствовали данные (null)."""

"""Первичным ключом таблицы является столбец или группа столбцов. Значения ключа должны быть
уникальными — таким образом предотвращается ввод одинаковых данных в таблицу. Этот ключ
индексируется для быстрого поиска во время выполнения запроса. Работа индекса немного похожа
на работу алфавитного указателя, который позволяет быстро найти определенный ряд. Каждая таблица
находится внутри родительской базы данных, как файлы в каталоге. Два уровня иерархии позволяют
немного лучше организовывать данные."""

"""Если вы хотите найти строки по определенному неключевому значению, определите для столбца
вторичный индекс. В противном случае база данных должна будет выполнить сканирование таблицы
— поиск нужного значения перебором всех строк. Таблицы могут быть связаны друг с другом с помощью
внешних ключей, и значения столбцов могут быть ограничены этими ключами"""

"""SQL
SQL не является API или протоколом. Это декларативный язык: вы говорите, что вам нужно, а не
как это сделать. SQL — универсальный язык реляционных баз данных. Запросы SQL являются 
текстовыми строками: клиент отсылает их серверу базы данных, а тот определяет, что с ними
делать дальше."""

"""Существует несколько стандартов определения SQL, но все поставщики баз данных добавили
свои собственные настройки и расширения, что привело к появлению множества диалектов SQL. 
Если вы храните данные в реляционной базе данных, SQL дает вам некоторую переносимость данных. 
Однако наличие диалектов и операционных различий может усложнить перенос данных в другую базу."""

"""Есть две основные категории утверждений SQL.
- DDL (Data Definition Language — язык определения данных). Обрабатывает создание, удаление, 
ограничения и разрешения для таблиц, баз данных и пользователей.
- DML (Data Manipulation Language — язык манипулирования данными). 
Обрабатывает добавление данных, их выборку, обновление и удаление"""
##################################################################################################
""" Основные команды SQL DDL"""
#       Операция                     Шаблон SQL                Пример SQL

# Создание базы данных          CREATE DATABASE имя_базы    CREATE DATABASE d

# Выбор текущей базы данных     USE имя_базы                USE d

# Удаление базы данных          DROP DATABASE имя_базы      DROP DATABASE d
# и ее таблиц

# Создание таблицы              CREATE TABLE имя_таблицы    CREATE TABLE t
#                                  (описания_столбцов)      (id INT, count INT)

# Удаление таблицы              DROP TABLE имя_таблицы      DROP TABLE t

# Удаление всех строк таблицы   TRUNCATE TABLE имя_таблицы  TRUNCATE TABLE t
##################################################################################################
"""Язык SQL не зависит от регистра, но по традиции ключевые слова ВЫКРИКИВАЮТСЯ, чтобы их можно
было отличить от имен столбцов."""
"""Основные операции DML реляционной базы данных можно запомнить с помощью акронима CRUD:
- Create — создание с помощью оператора SQL INSERT;
- Read — чтение с помощью SELECT;
- Update — обновление с помощью UPDATE;
- Delete — удаление с помощью DELETE.
"""
##################################################################################################
"""Основные команды SQL DML"""
# Операция                          Шаблон SQL                      Пример SQL

# Добавление строки             INSERT INTO имя_таблицы         INSERT INTO t VALUES(7, 40)
#                                   VALUES(…)

# Выборка всех строк            SELECT * FROM имя_таблицы       SELECT * FROM t
# и столбцов                    SELECT * FROM t

# Выборка всех строк            SELECT cols FROM имя_таблицы    SELECT id, count FROM t
# и некоторых столбцов

# Выборка некоторых строк       SELECT cols FROM                SELECT id, count from t
# и некоторых столбцов          имя_таблицы WHERE условие       WHERE count > 5 AND id = 9

# Изменение некоторых           UPDATE имя_таблицы SET          UPDATE t SET count = 3
# строк в столбце               col = значение WHERE условие    WHERE id = 5

# Удаление некоторых строк      DELETE FROM имя_таблицы         DELETE FROM t WHERE
#                               WHERE условие                   count <= 10 OR id = 16
###################################################################################################
"""DB-API
Программный интерфейс приложения (Application Programming Interface, API) —это набор функций,
которые вы можете вызвать, чтобы получить доступ к какой либо услуге. 
DB-API (http://bit.ly/db-api) — это стандартный API в Python, предназначенный для получения
доступа к реляционным базам данных. С его помощью вы можете написать одну программу,
которая работает с несколькими видами реляционных баз данных, вместо того чтобы писать
несколько программ для работы с каждым видом баз данных по отдельности."""
"""Рассмотрим его основные функции:
- connect() — создание соединения с базой данных. Этот вызов может включать
в себя такие аргументы, как имя пользователя, пароль, адреса сервера и пр.;
- cursor() — создание объекта курсора, предназначенного для работы с запросами;
- execute() и executemany() — запуск одной или нескольких команд SQL;
- fetchone(), fetchmany() и fetchall() — получение результатов работы функции execute()."""

"""SQLite
SQLite (http://www.sqlite.org/) — это хорошая легкая реляционная база данных с открытым
исходным кодом. Она реализована как стандартная библиотека Python и хранит базы данных в
обычных файлах. Эти файлы можно переносить в другие машины и операционные системы, что
делает SQLite портативным решением для простых приложений реляционных баз данных."""
"""Работа начинается с вызова connect() для установки соединения с локальным
файлом базы данных, который вы хотите создать или использовать. Этот файл
эквивалентен похожей на каталог базе данных, которая хранит таблицы на других
серверах. С помощью специальной строки ':memory:' можно создать базу данных
только в памяти — это быстро и удобно для тестирования, но данные будут потеряны
при завершении программы или выключении компьютера."""
"""создадим базу данных enterprise.db и таблицу zoo
critter — строка переменной длины, наш первичный ключ
count — целочисленное количество единиц используемого инвентаря для этого животного
damages — сумма, выраженная в долларах, наших убытков.
"""
import sqlite3
conn = sqlite3.connect('enterprise.db')
curs = conn.cursor()
curs.execute("""CREATE TABLE IF NOT EXISTS zoo
             (critter VARCHAR(20) PRIMARY KEY,
             count INT,
             damages FLOAT)""")
"""Существует безопасный способ добавить данные — использовать заполнитель
добавление строки со значениями соответствено стобцам  кортеж значений соответ. столбцам
"""
ins = 'INSERT INTO zoo (critter, count, damages) VALUES(?, ?, ?)'
"""мы использовали в запросе три вопросительных знака, чтобы показать, что мы планируем
вставить три значения, а затем передать эти значения в виде кортежа в функцию execute(). 
Передаем в кортеже данные согласно стобцам таблицы."""
curs.execute(ins, ('weasel', 1, 2000.0))    # ввод данных в таблицу zoo.
curs.execute(ins, ("bear", 2, 1000.0))      # ввод данных в таблицу zoo.
curs.execute(ins, ("duck", 5, 0.0))         # ввод данных в таблицу zoo.
"""Выведем все наши записи животных"""
curs.execute('SELECT * FROM zoo')   # делаем запрос на вывод всех столбцов и строк
rows = curs.fetchall()              # считываем значения из БД и помещаем их в rows
# print(rows)                         # вывод списка в консоль
"""упорядочим список по количеству животных в нисходящем порядке"""
curs.execute('SELECT * from zoo ORDER BY count DESC ')   # делаем запрос на вывод всех столбцов
# и строк, но по кол-ву животных count. от большего к малому
rows = curs.fetchall()              # считываем значения из БД и помещаем их в rows
# print(rows)                         # вывод списка в консоль
"""Какие животные обходятся нам дороже всего?"""
curs.execute('''SELECT * FROM zoo WHERE damages = (SELECT MAX(damages) FROM zoo)''')
# print(curs.fetchall())  # [('weasel', 1, 2000.0)]
"""Выведем всех животных от дорогих до дешевых"""
curs.execute("""SELECT critter, damages FROM zoo ORDER BY damages DESC""")
animal = curs.fetchall()
# for k, v in animal:
#     print(k, v)
# weasel 2000.0
# bear 1000.0
# duck 0.0
# print(*[f'\n{k} -> {v}' for k, v in animal])
# weasel -> 2000.0
# bear -> 1000.0
# duck -> 0.0
curs.close()    # закрываем соединение курсора
conn.close()    # закрываем соединение с БД

"""MySQL
MySQL (http://www.mysql.com/) — очень популярная реляционная база данных с открытым исходным кодом.
В отличие от SQLite она является настоящим сервером, поэтому клиенты могут получать к ней
доступ с разных устройств всей сети. Необходимы использовать драйверы для того,
чтобы получить доступ к MySQL из Python. За более подробной информацией обо всех драйверах
MySQL для Python обратитесь к энциклопедии на python.org (https://wiki.python.org/moin/MySQL)"""

"""PostgreSQL
PostgreSQL (http://www.postgresql.org/) — полнофункциональная реляционная база
данных с открытым исходным кодом, гораздо более продвинутая, чем MySQL. Необходимы использовать
драйверы для того,чтобы получить доступ. Самым популярным драйвером является psycopg2, но для его
установки требуется наличие клиентских библиотек PostgreSQL"""

"""SQLAlchemy
SQL не для всех реляционных баз данных одинаков, а DB-API дает вам ограниченный набор возможностей.
Каждая база данных реализует определенный диалект, отражая свои особенности и философию. 
Многие библиотеки пытаются тем или иным способом компенсировать эти различия. Самая популярная
библиотека для работы с разными базами данных — SQLAlchemy (http://www.sqlalchemy.org/).
Она не является стандартной, тем не менее широко известна и многими используется. Вы можете
установить ее в свою систему с помощью следующей команды: $ pip install sqlalchemy"""
"""Использовать SQLAlchemy можно на нескольких уровнях.
- Самый низкий уровень управляет пулами соединений с базами данных, выполняет команды SQL и 
возвращает результат. Это ближе всего к DB-API.
- Следующий уровень — язык выражений SQL, который позволяет вам выражать запросы более
Python-ориентированным способом.
- Самый высокий уровень — это ORM (Object Relational Model — объектно-реляционная модель), 
который использует язык выражений SQL Expression Language и связывает код приложения
с реляционными структурами данных."""
"""SQLAlchemy работает с драйверами базы данных. Вам не нужно импортировать драйвер — он будет
определен с помощью строки соединения, которую вы предоставите SQLAlchemy. Эта строка выглядит
примерно так:
диалект + драйвер :// пользователь : пароль @ хост : порт / имя_базы
В нее нужно поместить следующие значения:
- диалект — тип базы данных;
- драйвер, который вы хотите использовать для этой базы данных;
- пользователь и пароль — строки аутентификации для этой базы данных;
- хост и порт — расположение сервера базы данных (значение port нужно указывать только в том
случае, если вы используете нестандартный порт);
- имя_базы — имя базы данных, к которой нужно подключиться.
"""

"""Уровень движка.
Сначала обратимся к самому низкому уровню SQLAlchemy, возможности которого
почти не отличаются от функций DB-API. Строка соединения для SQLite опускает значения параметров
хост, порт, имя_пользователя и пароль. Имя имя_базы информирует SQLite о том, какой файл
использовать для хранения вашей базы данных. Если вы опустите параметр имя_базы, SQLite
создаст базу данных в памяти. 
"""
import sqlalchemy as sa

conn_3 = sa.create_engine('sqlite://')
conn_3.execute("""CREATE TABLE IF NOT EXISTS employees
                (name VARCHAR(20) PRIMARY KEY,
                 old INT,
                 sex BOOL)""")
"""Вызов conn_3.execute() возвращает объект SQLAlchemy, который называется ResultProxy."""
"""вставьте три набора данных в новую пустую таблицу"""
ins_3 = 'INSERT INTO employees (name, old, sex) VALUES (?, ?, ?)'   # заполнитель
conn_3.execute(ins_3, ('Sergey', 32, 1))
conn_3.execute(ins_3, ('Natasha', 30, 0))
conn_3.execute(ins_3, ('Sanch', 37, 1))
conn_3.execute(ins_3, ('Olya', 40, 0))
conn_3.execute(ins_3, ('Max', 27, 1))
"""Сделайте выборку того, что только что разместили в базе"""
rows_3 = conn_3.execute('SELECT * FROM employees')
"""В SQLAlchemy rows_3 не является списком — это специальный объект ResultProxy,
который мы не можем отобразить непосредственно"""
rows_3 # <sqlalchemy.engine.cursor.LegacyCursorResult object at 0x0000018FC386E2E0>
"""Однако вы можете итерировать по нему, как по списку, и получать по одному ряду за раз"""
# for row in rows_3:
#     print(row)
# ('Sergey', 32, 1)
# ('Natasha', 30, 0)
# ('Sanch', 37, 1)
# ('Olya', 40, 0)
# ('Max', 27, 1)

"""Язык выражений SQL. 
Следующий уровень SQLAlchemy — язык выражений SQL. Он предоставляет функции, которые позволяют
создать SQL для разных операций. Язык выражений обрабатывает большее количество различий в
диалектах, чем низкоуровневый слой движка, и может оказаться полезным промежуточным решением
для приложений, работающих с реляционными базами данных."""
"""Для того чтобы определить таблицу employees, вместо SQL начнем использовать язык выражений"""
conn_4 = sa.create_engine('sqlite://')
meta = sa.MetaData()
employees = sa.Table('employees', meta,
                     sa.Column('name', sa.String, primary_key=True),
                     sa.Column('old', sa.Integer),
                     sa.Column('sex', sa.Boolean)
                     )
"""Структура метода Table() совпадает со структурой таблицы. Поскольку наша таблица содержит
три столбца, в методе Table()тоже три вызова метода Column()."""
meta.create_all(conn_4)
"""employees представляет собой некий волшебный объект, который соединяет мир баз данных SQL
и мир структур данных Python."""
"""Запишите в таблицу данные с помощью новых функций языка выражений"""
conn_4.execute(employees.insert(('Sergey', 32, 1)))
conn_4.execute(employees.insert(('Natasha', 30, 0)))
conn_4.execute(employees.insert(('Sanch', 37, 1)))
conn_4.execute(employees.insert(('Olya', 40, 0)))
conn_4.execute(employees.insert(('Max', 27, 1)))
"""Далее создадим оператор SELECT. Функция employees.select() делает выборку всего, что содержится
в таблице, представленной объектом employees, как это сделала бы инструкция SELECT * FROM employees
в простом SQL"""
result = conn_4.execute(employees.select())
rows_4 = result.fetchall()
# print(rows_4)
# [('Sergey', 32, True), ('Natasha', 30, False), ('Sanch', 37, True),
# ('Olya', 40, False), ('Max', 27, True)]

"""Object-Relational Mapper (ORM).
В предыдущем подразделе объект employees был промежуточным звеном между SQL и Python. В самом
верхнем слое SQLAlchemy объектно-реляционное отображение (Object-Relational Mapper, ORM) использует
язык выражений SQL, но старается сделать реальные механизмы базы данных невидимыми. Вы определяете
классы, а ORM обрабатывает способ, с помощью которого они получают данные из базы данных и 
возвращают их обратно. Основная идея, на которой базируется сложный термин
«объектно-реляционное отображение», заключается в том, что вы можете ссылаться на объекты в своем
коде и придерживаться таким образом принципов работы с Python, но при этом использовать реляционную
базу данных. Мы определим класс Employees и свяжем его с ORM. На этот раз мы укажем SQLite
использовать файл employees.db так, чтобы мы могли убедиться в работе ORM."""
from sqlalchemy.ext.declarative import declarative_base
"""Вот так создается соединение"""
conn_5 = sa.create_engine('sqlite:///employees.db')
"""Теперь мы начинаем работать с SQLAlchemy ORM. Определяем класс Employees и связываем его 
атрибуты со столбцами таблицы"""

Base = declarative_base()

class Employees(Base):
    __tablename__ = 'employees'

    name = sa.Column('name', sa.String, primary_key=True)
    old = sa.Column('old', sa.Integer)
    sex = sa.Column('sex', sa.Boolean)

    def __init__(self, name, old, sex):
        self.name = name
        self.old = old
        self.sex = sex

    def __repr__(self):
        return f"<Employees({self.name}, {self.old}, {self.sex})>"
"""Следующая строка как по волшебству создает базу данных и таблицу"""
Base.metadata.create_all(conn_5)
"""Добавить данные в таблицу можно путем создания объектов Python. ORM управляет данными изнутри"""
first_obj = Employees('Sergey', 32, 1)
second_obj = Employees('Natasha', 30, 0)
third_obj = Employees('Sanch', 37, 1)
# print(first_obj)    # ('Sergey', 32, 1)
"""Далее мы указываем ORM перенести нас в страну SQL. Создаем сессию для коммуникации
 с базой данных"""
from sqlalchemy.orm import sessionmaker
Session = sessionmaker(bind=conn_5)
session = Session()
"""Внутри сессии записываем три созданных нами объекта в базу данных. Функция add() добавляет
один объект, а функция add_all() добавляет список"""
session.add(first_obj)
session.add_all([second_obj, third_obj])
"""Наконец, нам нужно завершить сессию"""
session.commit()
"""Файл employees.db был создан в текущем каталоге. Вы можете использовать программу командной
строки sqlite3, чтобы в этом убедиться. Вот так ORM работает на высоком уровне."""
"""Нужно определить какой из следующих уровней вам наиболее подходит для ваших нужд:
- простой DB-API, показанный ранее в этой главе в подразделе «SQLite»;
- движок SQLAlchemy;
- язык выражений SQLAlchemy;
- SQLAlchemy ORM."""









