import string, pickle

"""В 1989 году английский ученый Тим Бернерс-Ли впервые внес предложение помочь распространять
информацию внутри CERN, а также среди всего исследовательского сообщества. Он назвал
его World Wide Web (Всемирная паутина) и довольно быстро выделил три основные идеи, которые должны 
были лечь в основу ее дизайна:
- HTTP (Hypertext Transfer Protocol — протокол передачи гипертекста) — протокол для веб-клиентов и 
    серверов для обмена запросами и ответами;
- HTML (Hypertext Markup Language — гипертекстовый язык разметки) — формат для представления
    результатов;
- URL (Uniform Resource Locator — единообразный локатор ресурса) — способ уникально обозначить
    сервер и ресурс на этом сервере."""
"""В самом простом варианте использования веб-клиент соединяется с веб-сервером с помощью
протокола HTTP, запрашивает URL и получает HTML."""
"""Python особенно хорош для работы в Интернете на любом из таких уровней, как:
- клиенты для удаленного доступа;
- серверы, предоставляющие данные для сайтов и веб-API;
- веб-API и сервисы, позволяющие обмениваться данными другими способами, отличающимися от 
просматриваемых веб-страниц."""

"""Веб-клиенты
Низкоуровневая система проводящих путей Интернета называется 
Transmission Control Protocol/Internet Protocol (протокол управления передачей/интернетпротокол) 
или просто TCP/IP. Он перемещает байты между компьютерами, но не обращает внимания на то, что они
значат. Это работа высокоуровневых протоколов — определений синтаксиса для некоторых целей. 
HTTP — стандартный протокол для обмена данными в Сети. Всемирная паутина — это клиент-серверная
система. Клиент делает запрос серверу: он открывает соединение TCP/IP, отправляет URL и другую 
информацию с помощью HTTP и получает ответ. Формат ответа также определяется протоколом HTTP. 
Он включает в себя статус запроса и (в том случае, если запрос выполнен успешно) данные и формат
ответа. Самый известный веб-клиент — это браузер. Он может создавать HTTP-запросы несколькими 
способами. Вы можете инициировать запрос вручную, написав URL в адресной строке или нажав ссылку
на веб-странице. Очень часто для отображения сайта используются возвращаемые данные: 
HTML-документы, файлы JavaScript, файлы CSS и изображения, но данные могут быть любого типа, в том
числе и не предназначенные для отображения. Важный аспект HTTP — этот протокол не имеет состояния. 
Каждое создаваемое вами соединение HTTP не зависит от других. Это упрощает базовые операции, но
усложняет другие. Рассмотрим несколько примеров таких усложнений.
- Кэширование. Удаленный контент, который не меняется, должен быть сохранен веб-клиентом и 
    использован для того, чтобы не загружать его с сервера снова.
- Сессии. Интернет-магазин должен запоминать содержимое вашей корзины.
- Аутентификация. Сайты, которые требуют ваши имя пользователя и пароль, должны запоминать их, 
    пока вы авторизованы. 
Решения для описанных усложнений включают в себя cookie, в которых сервер
отправляет клиенту довольно специфическую информацию, позволяющую их распознать, когда клиент 
отправляет эти файлы назад."""

"""Стандартные веб-библиотеки Python
http управляет всеми деталями клиент-серверного взаимодействия HTTP:
- client выполняет всю работу на стороне клиента;
- server помогает написать веб-сервер Python;
- cookies и cookiejar управляют cookies, которые сохраняют данные между посещениями;
urllib работает на базе http:
- request обрабатывает клиентские запросы;
- response обрабатывает ответы сервера;
- parse разбивает URL на части.
"""
"""Воспользуемся стандартной библиотекой с целью получить что-либо с сайта."""
import urllib.request as ur
url = 'http://www.example.com/'
conn = ur.urlopen(url)
# print(conn)  # <http.client.HTTPResponse object at 0x0000017F1E355DF0>
# with open('example_com.txt', 'wt', encoding='utf-8') as file:
#     for el in conn:
#         file.write(el.decode("utf-8"))    # check example_com
# print(conn.status)  # 200. Значение 200 означает, что все прошло гладко.
"""Существуют десятки кодов статуса HTTP, объединенных в пять диапазонов в соответствии с их
первой цифрой (сотни):
- 1xx (информация) — сервер получил запрос, но имеет некую дополнительную информацию для клиента;
- 2xx (успех) — сработало, каждый код успеха, кроме 200, сообщает дополнительные детали;
- 3xx (перенаправление) — ресурс был перемещен, поэтому ответ возвращает клиенту новый URL;
- 4xx (ошибка клиента) — некие проблемы на стороне клиента, например знаменитая ошибка 404 
    (ресурс не найден). Код 418 (I’m a teapot) был первоапрельской шуткой;
- 5xx (ошибка сервера) — код 500 — общая ошибка. Вы можете встретить ошибку 502 (ошибочный шлюз), 
    если произошел разрыв связи между веб-сервером и машинным интерфейсом."""
"""Для большинства задач, связанных с разработкой веб-клиентов, 
проще использовать библиотеку requests."""
import requests
resp = requests.get(url)
# print(resp)               # <Response [200]>
# print(resp.text[0:100])

"""Веб-серверы
Веб-разработчики обнаружили, что Python хорошо подходит для написания веб-серверов и программ, 
работающих на серверной стороне. Это привело к появлению такого множества фреймворков. 
Веб-фреймворк предоставляет функции, позволяющие построить сайты, поэтому может решать большее
количество задач, чем простой веб-сервер (HTTP)."""

"""Простейший веб-сервер Python
Вы можете запустить простейший веб-сервер, просто введя одну строку кода Python:
$ python -m http.server
С помощью этой строки вы реализуете примитивный Python HTTP-сервер.
Если не возникло никаких проблем, то вы увидите исходное сообщение о статусе:
Serving HTTP on 0.0.0.0 port 8000 ...
Теперь вы можете запрашивать файлы, чьи пути относительны к вашему текущему каталогу, и они будут 
вам возвращены. Если вы введете в своем браузере строку http://localhost:8000, 
то должны увидеть список каталогов и сервер выведет на экран строки обращения к журналам, 
например такие:
127.0.0.1 - - [10/Oct/2022 09:40:29] "GET / HTTP/1.1" 200 -
127.0.0.1 - - [10/Oct/2022 09:40:38] "GET /Ch_17_Data_in_Space_Networks/ HTTP/1.1" 200 -
127.0.0.1 - - [10/Oct/2022 09:43:02] "GET / HTTP/1.1" 200 -
127.0.0.1 - - [10/Oct/2022 09:43:06] "GET /Ch_10_Objects_and_Classes/ HTTP/1.1" 200 -
127.0.0.1 - - [10/Oct/2022 09:43:19] "GET /Ch_2_Data_Types/ HTTP/1.1" 200 -
127.0.0.1 - - [10/Oct/2022 09:43:21] "GET /Ch_2_Data_Types/Python_types.py HTTP/1.1" 200 -
"""
"""Элементы localhost и 127.0.0.1 являются для TCP синонимами вашего локального компьютера, поэтому
сработают независимо от того, подключены ли вы к Интернету. 
Вы можете интерпретировать эти строки следующим образом:
- 127.0.0.1 — IP-адрес клиента;
- первый символ - — имя удаленного пользователя, если он присутствует;
- второй символ - — имя авторизующегося пользователя, если требуется;
- [10/Oct/2022 09:40:29] — дата и время доступа;
- "GET/HTTP/1.1" — команда, отправленная веб-серверу:
    - метод HTTP (GET);
    - запрошенный ресурс (/, верхний уровень);
    - версия HTTP (HTTP/1.1);
- последнее число (200) — код статуса HTTP, возвращенный веб-сервером."""
"""Щелкните на любом файле. и сервер занесет этот запрос в журнал.
По умолчанию используется порт 8000, но вы можете указать любой другой.
Этот сервер, написанный только на Python, лучше всего подходит для быстрых тестов. Вы можете 
выключить его, убив его процесс нажатием Ctrl+C.
"""
"""Традиционные веб-серверы, такие как Apache и NGINX, гораздо быстрее работают со статическими
файлами. Кроме того, этот простой сервер не может взаимодействовать с динамическим содержимым, 
в отличие от более продвинутых серверов, принимающих дополнительные параметры."""

"""Web Server Gateway Interface (WSGI)
Довольно быстро необходимость в простых файлах исчезает, и нам уже нужен сервер, который может 
запускать программы динамически. В первые годы существования Всемирной паутины общий интерфейс 
шлюза (Common Gateway Interface, CGI) был разработан для того, чтобы веб-серверы могли запускать 
внешние программы и возвращать результаты. CGI также обрабатывал получение входных аргументов
от клиента, передавая их через сервер сторонним программам. Однако программы запускались заново 
при каждом обращении клиента. Масштабировать такие системы было трудно, поскольку даже у небольших
программ время загрузки довольно велико. Чтобы избежать задержки запуска, люди начали встраивать 
интерпретатор языка в веб-сервер. Apache запускал код на PHP внутри своего модуля mod_php,
Perl — внутри модуля mod_perl и Python — внутри модуля mod_python. Далее код этих динамических 
языков мог быть выполнен внутри долгоиграющего процесса Apache, а не во внешних программах.
Альтернативный метод заключается в том, чтобы запускать динамический язык внутри отдельной 
долгоиграющей программы и заставить ее обмениваться данными с веб-сервером. Примерами таких 
программ являются FastCGI и SCGI. Веб-разработка на Python совершила рывок с появлением Web 
Server Gateway Interface (WSGI) — универсального API между веб-приложениями и веб-серверами.
Все веб-фреймворки и веб-серверы Python, показанные далее, используют WSGI. Обычно вам не нужно 
знать, как функционирует данный интерфейс (для этого многого и не потребуется), но знание 
основных принципов его функционирования может действительно помочь разработке. Такое соединение 
называется синхронным — за одним шагом следует другой.
"""
"""apache
Лучшим WSGI-модулем apache (http://httpd.apache.org/) является mod_wsgi 
(https://code.google.com/p/modwsgi). Он может запускать код, написанный на Python, внутри процесса
Apache или в отдельном процессе, который обменивается данными с Apache. Если вы используете Linux 
или OS X, в вашей системе apache уже установлен. Для Windows вам придется устанавливать его 
самостоятельно (http://bit.ly/apache-http).
Наконец, установите предпочитаемый веб-фреймворк Python, основанный на WSGI. Попробуем использовать
в наших примерах фреймворк bottle. Практически вся работа включает в себя конфигурирование 
Apache, что может оказаться довольно затруднительным"""

"""NGINX
Веб-сервер NGINX (http://nginx.org/) не имеет встроенного модуля Python. Вместо этого он 
обменивается данными с помощью отдельного сервера WSGI, такого как uWSGI или gUnicorn. Вместе 
они представляют собой очень быструю и удобную в конфигурации платформу для веб-разработки на 
Python. Вы можете установить nginx с его официального сайта http://wiki.nginx.org/Install.
Небольшая страница документации (https://oreil.ly/7FTPa) предоставляет инструкции, позволяющие 
объединить Flask, NGINX и uWSGI."""

"""Другие веб-серверы Python
Ниже перечислены некоторые независимые WSGI-серверы, написанные на Python, которые работают как 
apache или nginx и используют несколько процессов и/или потоков  для обработки одновременных 
запросов:
- uwsgi (http://projects.unbit.it/uwsgi);
- cherrypy (http://www.cherrypy.org/);
- pylons (http://www.pylonsproject.org/).
А это серверы, основанные на событиях, которые пользуются одним процессом, но избегают 
блокирования любым одиночным запросом:
- tornado (http://www.tornadoweb.org/);
- gevent (http://gevent.org/);
- gunicorn (http://gunicorn.org/)."""

"""Фреймворки для работы веб-серверами
Веб-серверы обрабатывают детали работы HTTP и WSGI, но вам нужно использовать веб-фреймворки, 
чтобы написать код на Python, который будет поддерживать сайт. Написать сайт на Python можно с
помощью множества веб-фреймворков . Веб-фреймворк обрабатывает как минимум запросы клиента и
ответы сервера. Большинство крупных веб-фреймворков могут решать такие задачи, как:
- обработка протокола HTTP;
- аутентификация (authn, или «кто ты?»);
- авторизация (authz, или «что ты можешь сделать?»);
- создание сессии;
- получение параметров;
- валидация параметров (обязательные/опциональные, тип, диапазон);
- обработка глаголов HTTP;
- маршрутизация (функции/классы);
- выдача статических файлов (HTML, JS, CSS, изображения);
- динамических данных (базы данных, сервисы);
- возврат значений и статусов HTTP.
Опциональные возможности:
- создание шаблонов для бэкенда;
- соединение с базами данных, ORM;
- ограничение скорости;
- асинхронные задачи.
"""

"""Bottle
Bottle состоит из одного файла Python, поэтому его довольно легко опробовать и развернуть. Bottle 
не является частью стандартной библиотеки Python, поэтому установите его с помощью следующей 
команды:
$ pip install bottle

check --> bottle1.py
Bottle использует декоратор route, чтобы связать URL со следующей функцией; в этом примере / (
главная страница) обрабатывается функцией home(). Запустите данный сценарий сервера.
Обратившись по адресу http://localhost:9999, вы должны увидеть следующее:
It isn't fancy, but it's my home page
Функция run() запускает встроенный тестовый веб-сервер bottle. Вам не нужно использовать его в 
программах, написанных с помощью bottle, но это может оказаться полезным на первых порах 
разработки и тестирования.

check --> bottle2.py and index.html
В вызове static_file() мы хотим получить файл index.html из каталога, указанного в root 
(в нашем случае в '.', текущем каталоге). Если код предыдущего примера все еще выполняется, 
то остановите его. Каждый раз, когда вы обращаетесь к странице http:/localhost:9999/, вы должны
видеть следующее: My new and improved home page!!!

check --> bottle3.py and index.html
пример, который демонстрирует, как передавать аргументы в URL и использовать их. У нас появилась 
новая функция echo(), в которую мы хотим передавать строковый аргумент через URL. За это отвечает
строка @route('/echo/<thing>') в предыдущем примере. Конструкция <thing> в маршруте означает: 
все, что находится в URL после /echo/, присваивается строковому аргументу thing, который 
передается функции echo. Далее перейдите в браузере по ссылке http://localhost:9999/echo/Mothra.
Вы должны увидеть следующее: Say hello to my little friend: Mothra!
Оставьте bottle3.py работать еще на пару минут, чтобы мы могли попробовать что-либо еще. Вы 
проверяли работу этих примеров, вводя URL в браузер и глядя на отображаемые страницы. Вы также 
можете использовать клиентские библиотеки, такие как requests, чтобы они выполняли работу за вас.

check --> bottle_test.py
Теперь запустите bottle_test.py. В терминале вы должны увидеть следующее: 
It worked! That almost never happens!
Перед вами небольшой пример юнит-теста.

У фреймворка Bottle больше возможностей, чем я вам показал. В частности, при вызове функции run()
можно попробовать добавить следующие аргументы:
- debug=True — создает страницу отладки, если вы получаете ошибку HTTP;
- reloader=True — перезагружает страницу в браузере, если вы измените хотя бы небольшой кусочек 
кода.
Все это хорошо задокументировано на сайте разработчика http://bottlepy.org/docs/dev
"""
from flask import Flask, render_template, request
"""Flask
Bottle — это хороший фреймворк для того, чтобы начать работу. Но если вам нужно больше 
возможностей, то попробуйте Flask. Он был создан в 2010 годую. Flask почти так же прост в 
использовании, как и Bottle, но поддерживает множество расширений, которые могут оказаться 
полезными в профессиональной веб-разработке, например аутентификацию с помощью Facebook 
и интеграцию с базами данных. Это решение мне нравится больше других веб-фреймворков Python,
поскольку в нем сбалансированы простота применения и богатый набор функций. Пакет flask включает 
в себя библиотеку WSGI werkzeug и библиотеку шаблонов jinja2. Вы можете установить его с помощью 
терминала:
$ pip install flask
Переделаем наш последний пример с использованием фреймворка Flask. Однако для начала нужно внести
несколько изменений.
- Во Flask каталог по умолчанию для статических файлов называется static, и URL для таких файлов
тоже начинается со /static. Мы изменяем папку на '.' (текущий каталог) и префикс URL на ' ' (
пустой), чтобы позволить URL / отображать файл index.html.
- В функции run() установка параметра debug=True активизирует также автоматическую перезагрузку,
тогда как фреймворк bottle для отладки и перезагрузки использует отдельные аргументы.

check --> flask1.py
Протестируйте главную страницу, введя в браузер следующий URL:
http://localhost:9999/
Вы должны увидеть следующее (как и в случае с bottle): My new and improved home page!!!
Попробуйте обратиться к конечной точке /echo:
http://localhost:9999/echo/Godzilla
Вы должны увидеть следующее: Say hello to my little friend: Godzilla
Есть еще одно преимущество установки параметра debug равным True при вызове метода run. Если в
серверном коде генерируется исключение, то Flask возвращает особую отформатированную страницу,
содержащую полезные сведения о том, что и где пошло не так. Даже больше: вы можете вводить команды
с целью увидеть значения переменных в программе сервера. Не устанавливайте параметр debug = True
на производственных веб-серверах. Таким образом потенциальные злоумышленники получат слишком много
информации о вашем сервере.
До сих пор примеры с использованием Flask повторяли то, что мы делали с помощью фреймворка Bottle.
Что такого может делать Flask в отличие от Bottle? Flask содержит jinja2 — более широкую систему
шаблонов. Рассмотрим небольшой пример одновременного применения jinja2 и Flask.

Создайте каталог templates и файл flask2.html внутри него.
check --> flask2.py
Cерверный код, который получает этот шаблон, заполняет значение аргумента thing, передаваемого 
нами, и отрисовывает его как HTML. Аргумент thing = thing утверждает, что для передачи переменной 
с именем thing в шаблон эта переменная содержит значение строки thing.
Второй аргумент в URL, echo, вы можете передать множеством способов. Передача аргумента как части 
пути URL. С помощью этого метода вы просто расширяете URL.
"""
# @app.route('/echo/<thing>/<place>')
# def echo(thing, place):
#     return render_template('flask3.html', thing=thing, place=place)
"""URL должен выглядеть так:"""
# http://localhost:9999/echo/Rodan/McKeesport
"""Вы должны увидеть следующее:"""
# Say hello to my little friend: Rodan. Alas, it just destroyed McKeesport!
"""Или же вы можете передать аргументы как параметры команды GET"""
# @app.route('/echo/')
# def echo():
#     thing = request.args.get('thing')
#     place = request.args.get('place')
#     return render_template('flask3.html', thing=thing, place=place)
"""В этот раз используйте такой URL:"""
# http://localhost:9999/echo?thing=Gorgo&place=Wilmerding
"""Вы должны увидеть следующее:"""
# Say hello to my little friend: Gorgo. Alas, it just destroyed Wilmerding!
"""Когда команда GET используется в URL, любые аргументы должны передаваться в формате
&ключ1=знач1&ключ2=знач2&...
Вы также можете использовать оператор словаря **, чтобы передать несколько аргументов в шаблон 
с помощью одного словаря"""
# @app.route('/echo/')
# def echo():
#     kwargs = {}
#     kwargs['thing'] = request.args.get('thing')
#     kwargs['place'] = request.args.get('place')
#     return render_template('flask3.html', **kwargs)
"""Элемент **kwargs действует как конструкция thing=thing, place=place. Используя этот словарь,
можно сэкономить немного времени, если входных аргументов много.
У языка шаблонов jinja2 гораздо больше возможностей."""

"""Django
Django (https://www.djangoproject.com/) — очень популярный веб-фреймворк, написанный на Python, 
особенно для крупных сайтов. Он содержит код ORM , позволяющий создавать автоматические веб-страницы
для типичных функций баз данных CRUD (создание, замена, обновление, удаление). 
Он также включает автоматические страницы администрирования для этих веб-страниц, но они 
предназначены для внутреннего использования среди программистов, а не размещения на публичных
веб-страницах."""

"""Другие фреймворки
Вы можете сравнить фреймворки с помощью онлайн-таблицы, размещенной по адресу 
http://bit.ly/web-frames:
- fastapi (https://fastapi.tiangelo.com/) обрабатывает как синхронные (WSGI), так и асинхронные 
(ASGI) вызовы, использует подсказки типов и генерирует тестовые страницы. 
Очень хорошо задокументирован. Рекомендую;
- web2py (http://www.web2py.com/) работает примерно с тем же, с чем и django, только
немного в другом стиле;
- pyramid (https://trypyramid.com/) появился из более раннего проекта pylons, с точки
зрения функционала похож на django;
- turbogears (http://turbogears.org/) поддерживает ORM, 
множество баз данных и несколько языков шаблонов;
- wheezy.web (http://pythonhosted.org/wheezy.web) более молодой фреймворк,
оптимизирован для повышения производительности. Недавние исследования показали,
что он работает быстрее других (http://bit.ly/wheezyweb);
- molten (https://moltenframework.com/) также использует подсказки типов, 
но поддерживает только WSGI;
- apistar (https://docs.apistar.com/) похож на fastapi, но это скорее инструмент для
валидации API, чем веб-фреймворк;
- masonite (https://docs.masoniteproject.com/) — аналог 
Ruby on Rails или Laravel, написанный на Python"""

"""Фреймворки для работы с базами данных
Интернет и базы данных — это неразлучная парочка: где одно, там и другое. В реальных приложениях
Python в какой-то момент вам может понадобиться предоставить веб-интерфейс (сайт и/или API)
реляционной базе данных.
Вы можете создать собственный интерфейс с помощью:
- веб-фреймворка, такого как Bottle или Flask;
- пакет для работы с БД, наподобие db-api или SQLAlchemy;
- драйвер для базы данных вроде pymysql.
Вместо этого вы также можете использовать один из пакетов, объединяющих Интернет и базы данных:
- connexion (https://connexion.readthedocs.io/);
- datasette (https://datasette.readthedocs.io/);
- sandman2 (https://github.com/jeffknupp/sandman2);
- flask-restless (https://flask-restless.readthedocs.io/).
Или можете использовать фреймворк со встроенной поддержкой баз данных, такой как Django."""

"""REST API
Зачастую данные доступны только внутри веб-страниц. При желании получить к ним доступ вам нужно
получить доступ к странице через браузер и прочитать ее. Если с момента вашего последнего визита
авторы сайта внесли какие-нибудь изменения, то местоположение и стиль данных могли измениться.
Вместо того чтобы публиковать веб-страницы, ВЫ МОЖЕТЕ ПРЕДОСТАВИТЬ ДОСТУП К ДАННЫМ ЧЕРЕЗ
ВЕБ-ИНТЕРФЕЙС ПРОГРАММИРОВАНИЯ ПРИЛОЖЕНИЙ (Application Programming Interface, API).
Клиенты получают доступ к вашему сервису, делая запросы к URL, и получают ответы, содержащие статус
и данные. Вместо HTML страниц данные имеют формат, который удобнее использовать в других 
программах, таких как JSON и XML.
Понятие «передача состояния представления» (Representational State Transfer,REST) было определено
Роем Филдингом (Roy Fielding) в его докторской диссертации. Многие продукты имеют REST-интерфейс
или интерфейс RESTful. На практике это часто означает, что они имеют веб-интерфейс — определения
URL, предназначенные для доступа к веб-сервису.
Сервис RESTful использует глаголы HTTP определенными способами, описанными далее:
- HEAD получает информацию о ресурсе, но не его данные;
- GET получает данные ресурса с сервера. Это стандартный метод, используемый вашим браузером. GET 
    не должен применяться для создания, изменения или удаления данных;
- POST создает новый ресурс;
- PUT заменяет существующий ресурс, создавая его, если его нет;
- PATCH частично обновляет ресурс;
- DELETE — этот глагол говорит сам за себя: DELETE удаляет. Мы за правдивость в рекламе!
Клиент RESTful также может запрашивать содержимое одного или нескольких типов с помощью заголовков
запроса HTTP. Например, сложный сервис с интерфейсом REST может принимать и возвращать данные в
строках JSON."""

"""Поиск и выборка данных
Иногда вам нужно получить немного больше информации — рейтинг фильма, цену акции или доступность 
продукта, — но требуемая информация доступна только на HTML-страницах, при этом окружена 
рекламой и посторонним контентом.
Вы можете извлечь необходимую информацию вручную, сделав следующее.
1. Введите URL в браузер.
2. Подождите, пока загрузится удаленная страница.
3. Просмотрите отображенную страницу на предмет необходимой информации.
4. Запишите ее где-нибудь.
5. Повторите процесс для связанных URL.
Однако гораздо более приятно автоматизировать некоторые из этих шагов. Программа, автоматически 
получающая данные из Сети, называется краулером. После того как содержимое было получено с одного
из удаленных веб-серверов, скрапер анализирует ее, чтобы найти иголку в стоге сена."""

"""Scrapy
Если вам нужно мощное решение, объединяющее в себе возможности краулера и скрапера, то стоит 
загрузить Scrapy (http://scrapy.org/):
Scrapy — это фреймворк, а не модуль, в отличие от BeautifulSoup. Он имеет больше возможностей, 
но зачастую его трудно настроить. Чтобы узнать больше о Scrapy, прочтите 
Scrapy at a Glance (https://oreil.ly/8IYoe) и руководство (https://oreil.ly/4H_AW)."""

"""BeautifulSoup
Если у вас уже есть HTML-данные с сайта и вы просто хотите извлечь оттуда данные, то вам подойдет 
BeautifulSoup (https://oreil.ly/c43mV). Анализировать HTML труднее, чем кажется. Это происходит 
потому, что большая часть HTML-кода на общедоступных веб-страницах технически некорректна: 
незакрытые теги, неправильная вложенность и прочие усложнения.  Чтобы установить BeautifulSoup, 
введите следующую команду (не забудьте поставить в конце 4, иначе pip попробует установить б
олее старую версию и, возможно, выдаст ошибку): $ pip install beautifulsoup4
мы определим функцию get_links(), которая делает грязную работу, и основную программу, 
получающую один или несколько URL как аргументы командной строки. check links.py
"""

"""Requests-HTML
Кеннет Ритц, автор популярного пакета для работы с веб-клиентами requests, написал новую 
библиотеку для скрапинга, которая называется Requests-HTML 
(http://html.python-requests.org/) (для Python 3.6 и более новых версий).
Она получает страницу и обрабатывает ее элементы, поэтому вы, например, можете найти все ссылки, 
все содержимое или атрибуты любого элемента HTML. Библиотека имеет простой дизайн, похожий на 
requests и другие пакеты этого автора. В конечном счете она может быть проще в использовании, 
чем BeautifulSoup или Scrapy."""

"""Напишем полноценную программу. Она будет искать видео с помощью API архива Internet Archive. 
Это один из немногих API, которые позволяют получить анонимный доступ, и он будет существовать 
и после того, как данная книга будет напечатана. Большинство веб-API требуют от вас получить 
ключ API и предоставлять его всякий  раз, когда вы хотите получить к нему доступ. Почему? 
Это «трагедия общин» — бесплатные ресурсы с анонимным доступом зачастую используются слишком много 
и неправильно. Вот почему у нас не может быть хороших сервисов.
Программа делает следующее:
- приглашает вас ввести часть названия фильма или видео;
- ищет элемент с таким названием в Internet Archive;
- возвращает список идентификаторов, имен и описаний;
- перечисляет их и просит вас выбрать один;
- отображает это видео в вашем браузере;
Сохраните данный файл под именем iamovies.py.  Функция search() использует библиотеку requests, 
чтобы получить доступ к URL и результаты и преобразовать их в формат JSON. Другие функции 
обрабатывают все остальное. Вы увидите использование включений списков, разбиения строк и других 
возможностей, которые были представлены в предыдущих главах."""

# TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS   TASKS

"""18.2. Создайте скелет сайта с помощью веб-сервера Flask. Убедитесь, что сервер начинает свою 
работу по адресу Localhost на стандартном порте 5000. Если ваш компьютер уже использует этот порт
для чего-то еще, то воспользуйтесь другим портом. Смотрите task_18_2.py"""
###################################################################################################
"""18.3. Добавьте функцию home() для обработки запросов к главной странице. Пусть она возвращает
строку It's alive!. Смотрите task_18_3.py"""
###################################################################################################
"""18.4. Создайте шаблон для jinja2, который называется home.html и содержит следующий контент:
<html>
<head>
<title>It's alive!</title>
<body>
I'm of course referring to {{thing}}, which is {{height}} feet tall and {{color}}.
</body>
</html>
Смотрите home.html"""
###################################################################################################
"""18.5. Модифицируйте функцию home() вашего сервера, чтобы она использовала шаблон home.html.
Передайте ей три параметра для команды GET: thing, height и color. Смотрите task_18_3.py"""

