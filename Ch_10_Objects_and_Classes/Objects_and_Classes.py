class Cat:
    def __init__(self, name):
        self.name = name


furball = Cat('Grumpy')  # furball.name --> Grumpy

"""Не обязательно иметь метод __init__() в описании каждого класса — он используется для 
того, чтобы различать объекты одного класса. Это не то, что в некоторых
других языках называется конструктором. Python уже создал объект для вас. Метод
__init__() следует рассматривать скорее как средство инициализации. Если класс Cat уже определен, 
как мы сделали в этой главе, то второй такой класс создать не получится. """

class Car:
    def exclaim(self):
        print("I'm a Car!")

class Yugo(Car):
    pass

"""Проверить, унаследован ли класс от другого класса, можно с помощью функции
issubclass()"""
issubclass(Yugo, Car)  # True

give_me_a_car = Car()
give_me_a_yugo = Yugo()
"""Если говорить в терминах объектно-ориентированных языков, Yugo является Car. Объект с 
именем give_me_a_yugo — это экземпляр класса Yugo, но он также наследует все то, 
что может делать класс Car."""
# give_me_a_car.exclaim()      # I'm a Car!
# give_me_a_yugo.exclaim()     # I'm a Car!

"""Многолетний опыт работы в объектно-ориентированном программировании показал, 
что чрезмерное увлечение наследованием может затруднить управление программами. 
Вместо этого рекомендуется сделать акцент на использовании других приемов, таких 
как агрегирование и композиция. """

"""Класс Yugo должен как-то отличаться от класса Car, иначе зачем вообще создавать новый класс.
Изменим способ работы метода exclaim() для класса Yugo_1"""
class Yugo_1(Car):
    def exclaim(self):
        print("I'm a Yugo! Much like a Car, but more Yugo-ish.")

give_me_a_car_1 = Car()
give_me_a_yugo_1 = Yugo_1()
# give_me_a_car_1.exclaim()   # I'm a Car!
# give_me_a_yugo_1.exclaim()  # I'm a Yugo! Much like a Car, but more Yugo-ish.

"""В этих примерах мы переопределили метод exclaim(). Переопределять можно любые методы,
включая __init__(). В производный класс можно добавить и метод, которого не было в родительском
классе."""

"""Получаем помощь от своего родителя с использованием метода super(). Мы видели, как 
производный класс может добавить или переопределить метод родительского класса. 
Но что, если нужно будет вызвать этот родительский метод?"""

class Person():
    def __init__(self, name):
        self.name = name

class EmailPerson(Person):
    def __init__(self, name, email):
        super().__init__(name)
        self.email = email

"""Когда вы определяете метод __init__() для своего класса, вы заменяете метод __init__()
родительского класса, который больше не вызывается автоматически. В результате вам
нужно вызывать его явно. 
- Метод super() получает определение родительского класса Person
- метод __init__() вызывает метод Person.__init__(). Последний заботится о том, чтобы передать 
аргумент self суперклассу, поэтому вам нужно просто дать ему любые необязательные аргументы. 
В нашем случае единственным аргументом класса Person() будет name"""

bob = EmailPerson('Bob Frapples', 'bob@frapples.com')
# bob.name    # 'Bob Frapples'
# bob.email   # 'bob@frapples.com'

"""Мы могли бы определить новый класс так у родителя, но тогда потеряли бы возможность 
применять наследование. Мы использовали метод super(), чтобы заставить Person делать свою работу
так же, как это делает обычный объект класса Person. Есть и другое преимущество:
если определение класса Person в будущем изменится, с помощью метода super()
мы сможем гарантировать, что атрибуты и методы, которые класс EmailPerson наследует от класса 
Person, отреагируют на изменения. Используйте метод super(), когда потомок делает что-то 
по-своему, но все еще нуждается в помощи родителя (как и в реальной жизни)."""



"""Множественное наследование. Объекты могут наследовать и от нескольких родительских классов.
Если ваш класс ссылается на метод или атрибут, которого у него нет, Python будет искать его в 
родительском классе. Что, если у нескольких классов будут атрибуты с одинаковыми именами?
 Кто победит? Наследование в Python зависит от порядка разрешения методов. Каждый класс Python 
 имеет особый метод mro(), возвращающий список классов, в которых будет выполнен поиск метода 
 или атрибута для объекта этого класса. Похожий атрибут с именем __mro__ представляет собой 
 кортеж, содержащий имена этих классов. Побеждает первый."""


class Animal:
    def says(self):
        return 'I speak!'

class Horse(Animal):
    def says(self):
        return 'Neigh!'

class Donkey(Animal):
    def says(self):
        return 'Hee-haw!'

class Mule(Donkey, Horse):
    pass

class Hinny(Horse, Donkey):
    pass

"""Если нам понадобится метод или атрибут класса Mule, Python будет искать его в следующих классах
по порядку.
1. Сам объект (типа Mule).
2. Класс объекта (Mule).
3. Первый родительский класс этого класса (Donkey).
4. Второй родительский класс этого класса (Horse).
5. Прародительский класс этого класса (Animal)."""

Mule.mro()
# [
# <class '__main__.Mule'>,
# <class '__main__.Donkey'>,
# <class '__main__.Horse'>,
# <class '__main__.Animal'>,
# <class 'object'>
# ]

mule = Mule()
hinny = Hinny()
mule.says()      # 'Hee-haw!'
hinny.says()     # 'Neigh!'

"""Если бы у классов Horse и Donkey не было метода says(), классы Mule и Hinny использовали 
бы метод says() прародительского класса Animal и возвратили бы значение 'I speak!'."""


# class A():
#     count = 0
#
#     def __init__(self):
#         A.count += 1
#
#     def exclaim(self):
#         print("I'm an A!")
#
#     @classmethod
#     def kids(cls):
#         print("A has", cls.count, "little objects.")
#
#     @staticmethod
#     def commercial():
#         print('This CoyoteWeapon has been brought to you by Acme')
#
# easy_a = A()
# breezy_a = A()
# wheezy_a = A()
# A.kids()
# A.commercial()
# breezy_a.kids()
# breezy_a.commercial()




